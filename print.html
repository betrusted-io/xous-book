<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Xous Operating System</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Xous Operating System</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-renode.html"><strong aria-hidden="true">1.3.</strong> Hello, Renode!</a></li><li class="chapter-item expanded "><a href="ch01-04-hello-hardware.html"><strong aria-hidden="true">1.4.</strong> Hello, Hardware!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-server-architecture.html"><strong aria-hidden="true">2.</strong> Server Architecture</a></li><li class="chapter-item expanded "><a href="ch03-00-introducing-the-kernel.html"><strong aria-hidden="true">3.</strong> Introducing the Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-memory-layout.html"><strong aria-hidden="true">3.1.</strong> Memory Layout</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-renode-emulation.html"><strong aria-hidden="true">4.</strong> Renode Emulation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-platform-definition.html"><strong aria-hidden="true">4.1.</strong> Platform Definition</a></li><li class="chapter-item expanded "><a href="ch04-02-renode-startup-script.html"><strong aria-hidden="true">4.2.</strong> Renode Startup Script</a></li><li class="chapter-item expanded "><a href="ch04-03-python-extensions.html"><strong aria-hidden="true">4.3.</strong> Python Extensions</a></li><li class="chapter-item expanded "><a href="ch04-04-writing-cs-peripherals.html"><strong aria-hidden="true">4.4.</strong> Writing C# Peripherals</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-system-startup.html"><strong aria-hidden="true">5.</strong> System Startup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-arguments.html"><strong aria-hidden="true">5.1.</strong> Arguments Structure</a></li><li class="chapter-item expanded "><a href="ch05-02-loader.html"><strong aria-hidden="true">5.2.</strong> Xous Loader</a></li><li class="chapter-item expanded "><a href="ch05-03-minielf.html"><strong aria-hidden="true">5.3.</strong> MiniELF Format</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-build-system-overview.html"><strong aria-hidden="true">6.</strong> Build System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-02-create-image.html"><strong aria-hidden="true">6.1.</strong> Image Creation</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-messages.html"><strong aria-hidden="true">7.</strong> Messages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Xous Operating System</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/betrusted-io/xous-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-xous-operating-system" id="the-xous-operating-system">The Xous Operating System</a></h1>
<p><em>by Sean &quot;xobs&quot; Cross and Andrew &quot;bunnie&quot; Huang, with contributions from the Rust Community</em></p>
<p>This version of the text assumes youâ€™re using Rust 1.58.1 with the Xous library
installed.</p>
<h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<p>This book is a work in progress. Like this one, many of the chapters are placeholders, and will appear blank.</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Work in progress.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>Work in progress. This and all subchapters are blank.</p>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<h1><a class="header" href="#hello-world" id="hello-world">Hello, World!</a></h1>
<h1><a class="header" href="#hello-renode" id="hello-renode">Hello, Renode!</a></h1>
<h1><a class="header" href="#hello-hardware" id="hello-hardware">Hello, Hardware!</a></h1>
<h1><a class="header" href="#server-architecture" id="server-architecture">Server Architecture</a></h1>
<h1><a class="header" href="#introducing-the-kernel" id="introducing-the-kernel">Introducing the Kernel</a></h1>
<h1><a class="header" href="#memory-management-in-xous" id="memory-management-in-xous">Memory Management in Xous</a></h1>
<p>Memory is allocated with the <code>MapMemory</code> syscall. This call accepts four arguments:</p>
<ul>
<li>physical: <code>Option&lt;NonZeroUsize&gt;</code>: The physical address you would like to allocate. Specify <code>None</code> if you don't need a particular address.</li>
<li>virtual: <code>Option&lt;NonZeroUsize&gt;</code>: The virtual address you would like to allocate. Specify <code>None</code> if you don't need a particular virtual address.</li>
<li>size: <code>NonZeroUsize</code>: The size of the region to allocate. This must be page-aligned.</li>
<li>flags: <code>MemoryFlags</code>: A list of platform-specific flags to apply to this region.</li>
</ul>
<p>The memory will return a <code>MemoryRange</code> that encompasses the given region.</p>
<p>You can free memory with <code>UnmapMemory</code>, though be very careful not to free memory that is currently in use. <code>UnmapMemory</code> simply takes the <code>MemoryRange</code> returned by <code>MapMemory</code>.</p>
<h2><a class="header" href="#physical-addresses" id="physical-addresses">Physical Addresses</a></h2>
<p>A program rarely needs to access physical addresses, and in most operating systems it's not the kind of thing you can actually <em>do</em>. However, Xous is designed to be embedded, so it's entirely legal to request a physical address.</p>
<p>The trick is that you can only request physical addresses that actually exist. For example, you cannot request a physical address for a mirrored region of a peripheral because that is not a valid address.</p>
<p><strong>If you request a physical address from main RAM, the memory will be zeroed when you receive it</strong>. Peripherals and ares that are not in main RAM will not be zeroed. It is for this reason that system services are recommended to claim all peripherals before running user programs.</p>
<h2><a class="header" href="#virtual-addresses" id="virtual-addresses">Virtual Addresses</a></h2>
<p>All Xous programs run with virtual memory enabled. Attempting to perform an illegal operation will result in an exception. If you have an exception handler installed, illegal memory accesses will run this exception handler which may fixup the exception.</p>
<h3><a class="header" href="#demand-paging" id="demand-paging">Demand Paging</a></h3>
<p>When you allocate memory using <code>MapMemory(None, None, ..., ...)</code>, you will be handed memory from the <code>DEFAULT_BASE</code>. This memory will not be backed by a real page, and will only be allocated by the kernel once you access the page. This allows threads to allocate large stacks without running out of memory immediately.</p>
<p>Pages that are mapped-but-unallocated are visible in a process' page table view. As an example, consider the following excerpt from a page table view:</p>
<pre><code class="language-text">    38 60026000 -&gt; 400a3000 (flags: VALID | R | W | USER | A | D)
    41 60029000 -&gt; 40108000 (flags: VALID | R | W | A | D)
    42 6002a000 -&gt; 40109000 (flags: VALID | R | W | A | D)
    43 6002b000 -&gt; 00000000 (flags: R | W)
    44 6002c000 -&gt; 00000000 (flags: R | W)
</code></pre>
<p>Addresses 0x60026000 (#38), 0x60029000 (#41), and 0x6002a000 (#42) are all allocated. The rest of the pages are valid-but-unallocated.</p>
<p>Address 0x60026000 (#38) is mapped to the process and has a valid physical address. Reads and writes to this page are backed by physical address 0x400a3000.</p>
<p>Addresses 0x60029000 (#41) and 0x6002a000 (#42) are still owned by the kernel, likely because they were being cleared.</p>
<p>Addresses 0x6002b000 (#43) and 0x6003c000 (#44) are on-demand allocated. They have no physical backing, and attempting to access them will result in a kernel fault where they will be allocated. When the page is allocated, it will be given the flags <code>R | W</code> in addition to default kernel flags.</p>
<h3><a class="header" href="#the-heap" id="the-heap">The Heap</a></h3>
<p>When we talk about &quot;The Heap&quot; we mean data that is managed by functions such as <code>malloc</code>. Xous has a pair of syscalls that behave vaguely like the Unix <code>brk</code> command.</p>
<p><code>IncreaseHeap(usize, MemoryFlags)</code> will increase a program's heap by the given amount. This returns the new heap as a <code>MemoryRange</code>.</p>
<p>To decrease the heap by a given amount, call <code>DecreaseHeap(usize)</code>.</p>
<p>Note that you must adjust the heap in units of <code>PAGE_SIZE</code>.</p>
<p>You can avoid using these syscalls by manually allocating regions using <code>MapMemory</code>, however they are a convenient abstraction with their own memory range.</p>
<p><code>liballoc</code> as bundled by Xous uses these syscalls as a backing for memory.</p>
<h3><a class="header" href="#virtual-memory-regions" id="virtual-memory-regions">Virtual Memory Regions</a></h3>
<p>There are different memory regions in virtual address space:</p>
<table><thead><tr><th>Address</th><th>Name</th><th>Variable</th><th>Description</th></tr></thead><tbody>
<tr><td>0x00010000</td><td>text</td><td>-</td><td>Start of <code>.text</code> with the default riscv linker script (<code>riscv64-unknown-elf-ld -verbose</code>)</td></tr>
<tr><td>0x20000000</td><td>heap</td><td>DEFAULT_HEAP_BASE</td><td>Start of the heap section returned by <code>IncreaseHeap</code></td></tr>
<tr><td>0x40000000</td><td>message</td><td>DEFAULT_MESSAGE_BASE</td><td>Base address where <code>MemoryMessage</code> messages are mapped inside of a server</td></tr>
<tr><td>0x60000000</td><td>default</td><td>DEFAULT_BASE</td><td>Default region when calling `MapMemory(..., None, ..., ...) -- most threads have their stack here</td></tr>
<tr><td>0x7fffffff</td><td>stack</td><td>-</td><td>The default stack for the first thread - grows downwards</td></tr>
<tr><td>0xff000000</td><td>kernel</td><td>USER_AREA_END</td><td>The end of user area and the start of kernel area</td></tr>
<tr><td>0xff400000</td><td>pgtable</td><td>PAGE_TABLE_OFFSET</td><td>A process' page table is located at this offset, accessible only to the kernel</td></tr>
<tr><td>0xff800000</td><td>pgroot</td><td>PAGE_TABLE_ROOT_OFFSET</td><td>The root page table is located at this offset, accessible only to the kernel</td></tr>
</tbody></table>
<p>In addition, there are special addresses that indicate the end of a function. The kernel will set these as the return address for various situations, and they are documented here for completeness:</p>
<table><thead><tr><th>Address</th><th>Name</th><th>Variable</th><th>Description</th></tr></thead><tbody>
<tr><td>0xff802000</td><td>retisr</td><td>RETURN_FROM_ISR</td><td>Indicates the return from an interrupt service routine</td></tr>
<tr><td>0xff803000</td><td>exitthr</td><td>EXIT_THREAD</td><td>Indicates a thread should exit</td></tr>
<tr><td>0xff804000</td><td>retex</td><td>RETURN_FROM_EXCEPTION_HANDLER</td><td>Indicates the return from an exception handler</td></tr>
</tbody></table>
<h1><a class="header" href="#renode-emulation" id="renode-emulation">Renode Emulation</a></h1>
<p><a href="https://renode.io/">Renode</a> is a multi-device emulator written in C#. It is designed to assist in testing and development of software, and is also useful in developing new hardware blocks.</p>
<p>The emulator is available for Windows, Mac, and Linux. It is designed to simulate whole systems of devices, meaning it can easily capture the interactions between devices on a network or bus. It allows you to pause the system and inspect memory, single-step, and watch various sections of the bus.</p>
<p>There is extensive end-user documentation available at <a href="https://renode.readthedocs.io/en/latest/">readthedocs</a>, which is highly recommended. The remainder of this chapter will cover recommendations on how to use Renode with Xous.</p>
<h1><a class="header" href="#writing-renode-c-peripherals" id="writing-renode-c-peripherals">Writing Renode C# Peripherals</a></h1>
<p>Renode is written in C#, which means it has access to the entire base of C#. One feature of C# is the <code>CSharpCodeProvider</code> object which provides the <code>CompileAssemblyFromSource(CompilerParameters, string[])</code> function. This means that Renode has a runtime C# compiler built in.</p>
<p>You can <code>include</code> C# files in the Renode console or in your startup script to dynamically add new peripherals to your environment. Xous uses this extensively in Betrusted since the hardware peripherals are still under development and therefore change regularly. Updating a hardware module in Renode simply involves modifying the <code>.cs</code> file and restarting Renode. There is no additional compile step.</p>
<h2><a class="header" href="#setting-up-an-ide----visual-studio-code" id="setting-up-an-ide----visual-studio-code">Setting up an IDE -- Visual Studio Code</a></h2>
<p>It is highly recommended to use a full IDE. The Renode API can change, and it can take time to restart Renode to recompile your C# files. An IDE will provide you with tab-completion and will immediately tell you if there is a code error.</p>
<p>The core of Renode is written in a full IDE such as Visual Studio or Monodevelop. These IDEs expect a full Project file that defines a single target output -- for example an executable or a linked library. With our usage of C# there is no single target since Renode will dynamically load the source files. To work around this, we create a stub project file that tricks the IDE into loading our assembly files and providing autocomplete. We never actually <em>use</em> this project file, but it's used behind the scenes automatically.</p>
<p>Broadly speaking, there are three steps to setting up an IDE:</p>
<ol>
<li>Download Visual Studio Code</li>
<li>Copy the reference project file</li>
<li>Modify the reference project file</li>
<li>Install the C# extension.</li>
</ol>
<p>To begin with download <a href="https://code.visualstudio.com/">Visual Studio Code</a>. It is available for Windows, Linux, and Mac.</p>
<p>Next, copy <code>emulation/peripherals.csproj.template</code> to <code>emulation/peripherals.csproj</code>. This is a C# Project file that is understood by Visual Studio and Visual Studio Code. The file name <code>peripherals.csproj</code> is in the <code>.gitignore</code> file, so don't worry about accidentally checking it in.</p>
<p>Edit <code>peripherals.csproj</code> and modify <code>RenodePath</code> to point to your Renode installation where the <code>.dll</code> files are located. On Linux this is likely <code>/opt/renode/bin</code>. On Windows this may be in <code>C:\Program Files\</code>.</p>
<p>Finally, install the <a href="https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp">C# for Visual Studio Code</a> extension. This extension will activate, parse your <code>.csproj</code>, and start providing autocomplete and compile suggestions.</p>
<h2><a class="header" href="#creating-a-new-peripheral" id="creating-a-new-peripheral">Creating a new Peripheral</a></h2>
<p>To create a new peripheral, simply copy an existing peripheral to a new filename under <code>emulation/peripherals/</code>, making sure the filename ends in <code>.cs</code>.</p>
<p>Many examples exist in the <code>emulation/peripherals/</code> directory, and you can find many more examples <a href="https://github.com/renode/renode-infrastructure/tree/master/src/Emulator/Peripherals/Peripherals">built into Renode</a>.</p>
<p>A simple example could be a device that provides random numbers:</p>
<pre><code class="language-cs">using Antmicro.Renode.Core;
using Antmicro.Renode.Core.Structure.Registers;
using Antmicro.Renode.Logging;

namespace Antmicro.Renode.Peripherals.Miscellaneous
{
    public class ExampleRNGServer : BasicDoubleWordPeripheral, IKnownSize
    {
        public long Size { get { return 0x100; } }
        public GPIO IRQ { get; private set; }
        private readonly PseudorandomNumberGenerator rng = EmulationManager.Instance.CurrentEmulation.RandomGenerator;
        private bool enabled = true;

        private enum Registers
        {
            CONTROL = 0x0,
            DATA = 0x4,
            STATUS = 0x8,
            AV_CONFIG = 0xc,
            RO_CONFIG = 0x10,

            READY = 0xc4,
            EV_STATUS = 0xc8,
            EV_PENDING = 0xcc,
            EV_ENABLE = 0xd0,
            URANDOM = 0xdc,
            URANDOM_VALID = 0xe0,
            TEST = 0xf8,
        }

        public ExampleRNGServer(Machine machine) : base(machine)
        {
            this.IRQ = new GPIO();
            DefineRegisters();
        }


        private void DefineRegisters()
        {

            Registers.URANDOM.Define(this)
                .WithValueField(0, 32, FieldMode.Read, valueProviderCallback: _ =&gt;
                {
                    if (!enabled)
                        return 0;
                    return (uint)rng.Next();
                }, name: &quot;URANDOM&quot;);
            Registers.DATA.Define(this)
                .WithValueField(0, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
                {
                    if (!enabled)
                        return 0;
                    return (uint)rng.Next();
                }, name: &quot;DATA&quot;)
                .WithValueField(16, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
                {
                    return 0xf00f;
                }, name: &quot;SIGNATURE&quot;);
            Registers.URANDOM_VALID.Define(this)
                .WithFlag(0, FieldMode.Read, valueProviderCallback: _ =&gt; { return true; }, name: &quot;URANDOM_VALID&quot;)
                .WithFlag(1, FieldMode.Read, valueProviderCallback: _ =&gt; { return enabled; }, name: &quot;ENABLE&quot;);

            Registers.CONTROL.Define(this)
                .WithFlag(0, FieldMode.Write, writeCallback: (_, val) =&gt; { enabled = val; }, name: &quot;ENABLE&quot;);
        }
    }
}
</code></pre>
<p>There's a lot to take in there, particularly if you've never dealt with C# before. Let's go over the module line-by-line.</p>
<pre><code class="language-cs">using Antmicro.Renode.Core;
using Antmicro.Renode.Core.Structure.Registers;
using Antmicro.Renode.Logging;
</code></pre>
<p>The first three lines import various packages to the current namespace. You'll most likely use these in all of your projects. Any valid C# namespace may be used, including core <code>.Net</code> libraries. This can be useful if you need networking, cryptography, or other exotic libraries. There are many useful logging functions as well. You'll notice that the final line is darker than the other two. This is because this package is currently unused -- we don't perform any logging currently. You can safely remove this final line, however it's useful to leave Logging as an import because it allows for autocompletion of Logging functions.</p>
<pre><code class="language-cs">namespace Antmicro.Renode.Peripherals.Miscellaneous {
</code></pre>
<p>Next, we define the namespace for this module. The module MUST be under a <code>namespace Antmicro.Renode.Peripherals.xxx</code> namespace. In this case, it is under <code>Antmicro.Renode.Peripherals.Miscellaneous</code>. This namespacing provides a handy structure to various peripherals.</p>
<pre><code class="language-cs">public class ExampleRNGServer : BasicDoubleWordPeripheral, IKnownSize {
</code></pre>
<p>Finally, we begin to define our class. This class is named <code>ExampleRNGServer</code>, and it inherits <code>BasicDoubleWordPeripheral</code> and <code>IKnownSize</code>.</p>
<p>The <code>BasicDoubleWordPeripheral</code> class provides several convenience functions that makes it easy to create a memory-mapped device. It means we don't need to manage accessors, and we can simply worry about the register values themselves.</p>
<p>Peripherals need to have a known size, so we inform C# that our client has a known size. The <code>I</code> stands for Interface. To find out which functions we must implement to conform to <code>IKnownSize</code>, hold Ctrl and click on <code>IKnownSize</code>. It will take you to the definition of <code>IKnownSize</code>, located inside <code>Emulator.dll</code>. You will note that the only thing we need to implement is <code>log Size { get; }</code>, which means we only need to create an accessor for the property <code>Size</code>.</p>
<pre><code class="language-cs">public long Size { get { return 0x100; } }
public GPIO IRQ { get; private set; }
private readonly PseudorandomNumberGenerator rng = EmulationManager.Instance.CurrentEmulation.RandomGenerator;
private bool enabled = true;
</code></pre>
<p>Here we define our local properties and variables. We can see the <code>Size</code> property defined here. Our peripheral goes up to <code>0xf8</code>, so we return that as a constant. This is used by Renode to ensure peripherals don't overlap, and to know which peripheral to invoke when memory is accessed.</p>
<p>There is an IRQ here as well, which is a <code>GPIO</code>. The way Renode handles interrupts is by reusing GPIO pins. We can trigger an interrupt by setting this GPIO, and the system will invoke an interrupt context on the CPU.</p>
<p>Finally there is a local variable that is part of this object and not visible outside of our class.</p>
<pre><code class="language-cs">private enum Registers
{
    CONTROL = 0x0,
    DATA = 0x4,
    STATUS = 0x8,
    AV_CONFIG = 0xc,
    RO_CONFIG = 0x10,

    READY = 0xc4,
    EV_STATUS = 0xc8,
    EV_PENDING = 0xcc,
    EV_ENABLE = 0xd0,
    URANDOM = 0xdc,
    URANDOM_VALID = 0xe0,
    TEST = 0xf8,
}
</code></pre>
<p>We define an enum called <code>Registers</code>. This is simply a mapping of register names to register numbers. It is not a particularly special enum, however correct naming of the enum values will make it easier to define the register set later on. It is standard practice to define all possible registers in this enum, even if you do not implement them right away.</p>
<pre><code class="language-cs">public ExampleRNGServer(Machine machine) : base(machine)
{
    this.IRQ = new GPIO();
    DefineRegisters();
}
</code></pre>
<p>This is the constructor for our device. It takes a single argument of type <code>Machine</code>. Because we inherit from <code>BasicDoubleWordPeripheral</code>, we will need to call the constructor for the base class. To figure out what the constructor looks like, hold Ctrl and click on <code>BasicDoubleWordPeripheral</code>. We can see that the constructor for that class simply takes one argument that's a <code>Machine</code>. Therefore, the first line of our constructor should invoke the base constructor directly. Which is what we do here.</p>
<p>We create a new GPIO and assign it to the IRQ. Renode will access our <code>IRQ</code> property if it wants to watch for interrupts. If our peripheral has no interrupts we can omit the <code>IRQ</code> property.</p>
<pre><code class="language-cs">private void DefineRegisters() {
</code></pre>
<p>Finally, we invoke the <code>DefineRegisters()</code> function. It is the most complicated function in this class, however it's where most of the work is done. Let's look at each register definition in order.</p>
<pre><code class="language-cs">Registers.URANDOM.Define(this)
    .WithValueField(0, 32, FieldMode.Read, valueProviderCallback: _ =&gt;
    {
        if (!enabled)
            return 0;
        return (uint)rng.Next();
    }, name: &quot;URANDOM&quot;);
</code></pre>
<p>The <code>Define(this)</code> function comes from <code>BasicDoubleWordPeripheralExtensions</code>, which is one of the classes provided to us as a subclass of <code>BasicDoubleWordPeripheral</code>. It allows us to define a register on an enum type.</p>
<p>The <code>WithValueField()</code> function defines a value for a register across a range of values. In this case, we define a value beginning at bit 0 that is 32-bits wide. We define this register as a <code>FieldMode.Read</code> register, meaning writes will be ignored. When a device accesses this register, the <code>valueProviderCallback</code> function will be called.</p>
<p>What follows is a C# closure. The first argument is the register itself, which we ignore since we are not interested in it. Therefore, the variable is named <code>_</code>. If the block is disabled, we return 0, otherwise we return a <code>uint</code> from the class RNG provider.</p>
<p>Finally, we name the register <code>URANDOM</code>.</p>
<pre><code class="language-cs">Registers.DATA.Define(this)
    .WithValueField(0, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
    {
        if (!enabled)
            return 0;
        return (uint)rng.Next();
    }, name: &quot;DATA&quot;)
    .WithValueField(16, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
    {
        return 0xf00f;
    }, name: &quot;SIGNATURE&quot;);
</code></pre>
<p>This register contains two value fields. The first is at offset 0, and is 16-bits wide. The second is at offset 16, and is also 16-bits wide.</p>
<p>The <code>valueProviderCallback</code> function is called for each field, which avoids the need for any manual bit shifting.</p>
<p>If the peripheral is not enabled, then the <code>DATA</code> field returns 0. If it is enabled, then it returns a 16-bit random value.</p>
<p>Because of the way this register is defined, the top 16 bits will always be <code>0xf00f</code>. Therefore, the register's value will be either <code>0xf00f0000</code> or <code>0xf00fRAND</code>.</p>
<pre><code class="language-cs">Registers.URANDOM_VALID.Define(this)
    .WithFlag(0, FieldMode.Read, valueProviderCallback: _ =&gt; { return true; }, name: &quot;URANDOM_VALID&quot;)
    .WithFlag(1, FieldMode.Read, valueProviderCallback: _ =&gt; { return enabled; }, name: &quot;ENABLE&quot;);
</code></pre>
<p>This register defines two flags. The first flag is at bit 0, and the second flag is at bit 1. Flags are always one-bit boolean values, which is why the <code>valueProviderCallback</code> returns <code>true</code> instead of a <code>uint</code> like we've seen in the past. Similarly to <code>WithValueField()</code>, a <code>WithFlag</code> value will call the <code>valueProviderCallback</code> for each flag, avoiding the need to do complex shifting.</p>
<pre><code class="language-cs">Registers.CONTROL.Define(this)
    .WithFlag(4, FieldMode.Write, writeCallback: (_, val) =&gt; { enabled = val; }, name: &quot;ENABLE&quot;);
</code></pre>
<p>Finally we define the <code>CONTROL</code> register. Our implementation simply has an <code>ENABLE</code> bit at offset 4. This is the first time we've seen a <code>writeCallback</code>. This closure takes two arguments: the register itself and the written value. </p>
<h2><a class="header" href="#using-the-new-peripheral" id="using-the-new-peripheral">Using the new peripheral</a></h2>
<p>To use the new peripheral, save it in a <code>.cs</code> file, then include it in Renode. For example, if it was called <code>examplerngserver.cs</code>, you would include it in Renode by running:</p>
<pre><code class="language-text">(renode) i @examplerngserver.cs
</code></pre>
<p>You can then use the <code>Miscellaneous.ExampleRNGServer</code> peripheral in any platform definition. For example, to create a new peripheral at offset <code>0x40048000</code> in the current machine, use the <code>LoadPlatformDescriptionFromString</code> command:</p>
<pre><code class="language-text">(renode) machine LoadPlatformDescriptionFromString 'rng: Miscellaneous.ExampleRNGServer @ sysbus 0x40048000'
</code></pre>
<p>Now, any accesses to <code>0x40048000</code> will be directed to your new peripheral.</p>
<h1><a class="header" href="#xous-operating-system-startup" id="xous-operating-system-startup">Xous Operating System Startup</a></h1>
<p>The Xous operating system is set up by the loader, which is responsible for unpacking data into RAM and setting up processes. It is covered in the <a href="ch05-02-loader.html">Xous Loader</a> section.</p>
<p>The loader reads a binary stream of data located in a tagged format that is discussed in the <a href="ch05-01-arguments.html">Arguments Structure</a> section. This arguments structure defines features such as the memory layout, system configuration, and initial process data.</p>
<p>Programs are loaded in flattened foramts called <code>MiniELF</code>, which is documented in the <a href="ch05-03-minielf.html">MiniELF Format</a> section.</p>
<h1><a class="header" href="#system-arguments" id="system-arguments">System Arguments</a></h1>
<p>The loader and kernel use a tagged format for defining system arguments. This tagged structure is designed to be small, and only describes data. The structure does not include any executable data. Instead, it contains references to this data that may be located immediately after the structure on a storage medium.</p>
<p>The tagged structure defines a prefix that is tagged by an 8-byte structure:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Tag {
    /// Ascii-printable name, not null-terminated, in little endian format.
    tag: u32,

    /// CRC16 of the data section, using CCITT polynomial.
    crc16: u16,

    /// Size of the data section, in 4-byte words.
    size: u16,
}
<span class="boring">}
</span></code></pre></pre>
<p>Tags are stored sequentially on disk, meaning a reader can skip over tags that it does not recognize. Furthermore, it can use a combination of <code>crc16</code> and <code>size</code> to determine that it has found a valid section.</p>
<p>The <code>size</code> field is in units of 4-bytes. Therefore, a <code>Tag</code> that contains only four bytes of data (for a total of 12-bytes on disk including the <code>Tag</code>) would have a <code>size</code> value of <code>1</code>.</p>
<h2><a class="header" href="#xarg-tag----xous-arguments-meta-tag" id="xarg-tag----xous-arguments-meta-tag"><code>XArg</code> tag -- Xous Arguments Meta-Tag</a></h2>
<p>The only ordering requirement for tags is that the first tag should be an <code>XArg</code> tag. This tag indicates the size of the entire structure as well as critical information such as the size of RAM.</p>
<p>Future revisions may add to this tag, however the size will never shrink.</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>4</td><td>Arg Size</td><td>The size of the entire args structure, including all headers, but excluding any trailing data (such as executables)</td></tr>
<tr><td>4</td><td>4</td><td>Version</td><td>Version of the XArg structure.  Currently <code>1</code>.</td></tr>
<tr><td>8</td><td>4</td><td>RAM Start</td><td>The origin of system RAM, in bytes</td></tr>
<tr><td>12</td><td>4</td><td>RAM Size</td><td>The size of system RAM, in bytes</td></tr>
<tr><td>16</td><td>4</td><td>RAM Name</td><td>A printable name for system RAM</td></tr>
</tbody></table>
<h3><a class="header" href="#xkrn-tag----xous-kernel-description" id="xkrn-tag----xous-kernel-description"><code>XKrn</code> tag -- Xous Kernel Description</a></h3>
<p>This describes the kernel image.  There must be exactly one <code>XKrn</code> tag in an arguments structure.
This image will get mapped into every process within the final 4 megabytes, and therefore the text and data
offsets must be in the range <code>0xffc0_0000</code> - <code>0xfff0_0000</code>.</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>4</td><td>LOAD_OFFSET</td><td>Physical address (or offset) where the kernel is stored</td></tr>
<tr><td>4</td><td>4</td><td>TEXT_OFFSET</td><td>Virtual memory address where the kernel expects the program image to live.  This should be <code>0xffd00000</code>.</td></tr>
<tr><td>8</td><td>4</td><td>TEXT_SIZE</td><td>Size of the text section.  This indicates how many bytes to copy from the boot image.</td></tr>
<tr><td>12</td><td>4</td><td>DATA_OFFSET</td><td>Virtual memory address where the kernel expects the .data/.bss section to be.  This should be above <code>0xffd00000</code> and below  <code>0xffe00000</code></td></tr>
<tr><td>16</td><td>4</td><td>DATA_SIZE</td><td>Size of the .data section</td></tr>
<tr><td>20</td><td>4</td><td>BSS_SIZE</td><td>The size of the .bss section, which immediately follows .data</td></tr>
<tr><td>24</td><td>4</td><td>ENTRYPOINT</td><td>Virtual address of the <code>_start()</code> function</td></tr>
</tbody></table>
<p>The kernel will run in Supervisor mode, and have its own private stack. The address of the stack will be generated by the loader.</p>
<h3><a class="header" href="#inie-tag----initial-elf-programs" id="inie-tag----initial-elf-programs"><code>IniE</code> tag -- Initial ELF Programs</a></h3>
<p>The <code>IniE</code> tag describes how to load initial processes.  There is one <code>IniE</code> for each initial program. There must be at least one <code>IniE</code> tag.</p>
<p>This tag has the following values:</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>4</td><td>LOAD_OFFSET</td><td>Position in RAM relative to the start of the arguments  block where this program is stored, or an absolute value if <code>ABSOLUTE</code>  is <code>1</code>.</td></tr>
<tr><td>4</td><td>4</td><td>ENTRYPOINT</td><td>Virtual memory address of the <code>_start()</code> function</td></tr>
</tbody></table>
<p>Following this is a list of <em>section definitions</em>. Section definitions must be sequential in RAM -- that is, it is not permitted for <code>SECTIONn_OFFSET</code> to decrease.
| Offset | Size | Name            | Description                                  |
| ------ | ---- | --------------- | -------------------------------------------- |
| n<em>3+8  | 8    | SECTIONn_OFFSET | Virtual memory address of memory section <em>n</em> |
| n</em>3+12 | 3    | SECTIONn_SIZE   | Size of memory section <em>n</em>                   |
| n*3+15 | 1    | SECTIONn_FLAGS  | Flags describing memory section <em>n</em>          |</p>
<p>The fields <code>size</code>, <code>flags</code>, and <code>offset</code> together occupy 64 bits (8 bytes). The
<code>OFFSET</code> is a full 32-bit address.  The <code>SIZE</code> field is in units of
bytes, however as it is only 24 bits, meaning the largest section size
is <code>2^24</code> bytes.</p>
<p>The <code>FLAGS</code> field contains the following four bits.  Any region may be
marked NOCOPY, however RISC-V does not allow regions to be marked
&quot;Write-only&quot;:</p>
<table><thead><tr><th>Bit</th><th>Binary</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>0b0001</td><td>NOCOPY</td><td>No data should be copied -- useful for <code>.bss</code></td></tr>
<tr><td>1</td><td>0b0010</td><td>WRITABLE</td><td>Region will be allocated with the &quot;W&quot; bit</td></tr>
<tr><td>2</td><td>0b0100</td><td>READABLE</td><td>Region will be allocated with the &quot;R&quot; bit</td></tr>
<tr><td>3</td><td>0b1000</td><td>EXECUTABLE</td><td>Region will be allocated with the &quot;X&quot; bit</td></tr>
</tbody></table>
<p>Programs <strong>cannot</strong> access the final four megabytes, as this memory
is reserved for the kernel. It is an error if any section enters this memory region.</p>
<h3><a class="header" href="#pnam-tag----program-names" id="pnam-tag----program-names"><code>PNam</code> Tag -- Program Names</a></h3>
<p><code>PNam</code> maps process IDs to process names. If multiple <code>PNam</code> tags exist
within a block, the first one that is encountered should take precedence.
This tag is a series of entries that take the following format:</p>
<table><thead><tr><th>Size (bytes)</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>4</td><td>PID</td><td>ID of the process that this name describes</td></tr>
<tr><td>4</td><td>Length</td><td>The length of the data that follows</td></tr>
<tr><td>varies</td><td>Data</td><td>The UTF-8 name string</td></tr>
</tbody></table>
<h3><a class="header" href="#bflg-tag----boot-flags" id="bflg-tag----boot-flags"><code>Bflg</code> Tag -- Boot Flags</a></h3>
<p>This configures various bootloader flags.  It consists of a single word
of data with various flags that have the following meaning:</p>
<ul>
<li>0x00000001 <code>NO_COPY</code>  -- Skip copying data to RAM.</li>
<li>0x00000002 <code>ABSOLUTE</code> -- All program addresses are absolute.
Otherwise, they're relative to the start of the config block.</li>
<li>0x00000004 <code>DEBUG</code>    -- Allow the kernel to access memory inside user
programs, which allows a debugger to run in the kernel.</li>
</ul>
<h3><a class="header" href="#mrex-tag----additional-memory-regions" id="mrex-tag----additional-memory-regions"><code>MREx</code> Tag -- Additional Memory Regions</a></h3>
<p>This tag defines additional memory regions beyond main system memory. This region omits main system memory, which is defined in the <code>XArg</code> tag.
The format for this tag consists of a single word defining how many additional sections there are, followed by actual section entries:</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>4</td><td>Count</td><td>The number of additional memory entries</td></tr>
</tbody></table>
<p>Each additional memory entry is 3 words of 4-bytes each:</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>n*3 + 4</td><td>4</td><td>Start</td><td>The start offset of this additional region</td></tr>
<tr><td>n*3 + 8</td><td>4</td><td>Length</td><td>The length of this additional region</td></tr>
<tr><td>n*3 + 12</td><td>4</td><td>Name</td><td>A 4-character name of this region that should be printable -- useful for debugging</td></tr>
</tbody></table>
<p>Additional memory regions should be non-overlapping. Creating overlapping memory regions will simply waste memory, as the loader will allocate multiple regions to track the memory yet will only allow it to be shared once.</p>
<h1><a class="header" href="#xous-loader" id="xous-loader">Xous Loader</a></h1>
<p>The Xous loader is located in the <a href="https://github.com/betrusted-io/xous/tree/main/loader">loader/</a> directory. This program runs in Machine mode, and makes the following assumptions:</p>
<ol>
<li>There is an Argument structure located somewhere in memory and register <code>$a0</code> points to it</li>
<li>The system has 16 MB of RAM and it is located at address <code>0x40000000</code></li>
</ol>
<p>Point #2 is flexible, and the loader has the ability to read the memory configuration out of the Argument structure, if one can accept trusting these parameters before the Argument structure is checked. However, in the current implementation, these values are hard-coded into the loader binary so that they are derived from an already verified, trusted location (see Loader Signature Checking below for why this is the case).</p>
<p>After passing the signature check, the loader runs the main loader sequence. The loader runs in two stages. The first stage is resposible for determining how much memory is required for each initial process as well as the kernel, and loading them into memory. The second stage sets up the platform-specific page tables.</p>
<h2><a class="header" href="#signature-checking-the-kernel" id="signature-checking-the-kernel">Signature Checking the Kernel</a></h2>
<p>We do not discuss precisely how we come to trust the loader itself: this responsibility falls onto a bootloader that is assumed to be burned into the ROM of the SoC running Xous. Please refer to <a href="https://github.com/betrusted-io/betrusted-wiki/wiki/How-Does-Precursor-Get-to-the-Reset-Vector%3F">this page</a> for an example of one implementation for getting to the reset vector. It turns out in Precursor that the process to check the loader is identical to that of checking the kernel.</p>
<p>Loader conditions #1 and #2, as outlined above, are set up by the bootloader. The following context is helpful to appreciate why we hard-code the RAM address and offset instead of reading it out of the loader Arguments:</p>
<ul>
<li>The Arguments to the loader describe the location and size of Kernel objects, in addition to encoding the amount and location of RAM</li>
<li>The loader and its Arguments are located in FLASH, so that it may be updated</li>
<li>It is expensive and hard to update the loader's digital signature recorded in the SoC, as it is often burned to a bank of OTP fuses</li>
<li>We assume that Kernel updates are routine, but loader updates are infrequent</li>
</ul>
<p>Because the Arguments are tightly coupled to the Kernel image, we cannot check them at the same time that the loader binary. Therefore, we must treat the Arguments as untrusted at the entry point of the loader, and ask the loader to verify the Arguments. However, the loader needs to know its location and extent of RAM to run any Argument checking. Thus this presents a circular dependency: how are we to know where our memory is, when the structure that describes our memory is designed to be changed frequently? The method chosen to break this circular dependency is to hard-code the location and amount of RAM in the loader binary itself, thus allowing the Arguments that describe the kernel to be malleable with a signature check stored in FLASH.</p>
<p>Signatures for both the loader and the kernel share a common structure. They consist of two sections: the detached signature, and the signed data itself. The detached signature has the following format in memory:</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>4</td><td>Version</td><td>Version number of the signature record. Currently <code>1</code></td></tr>
<tr><td>4</td><td>4</td><td>Length</td><td>Length of the signed region (should be exactly +4 over the Length field in the signed region)</td></tr>
<tr><td>8</td><td>64</td><td>Signature</td><td>64-byte Ed25519 signature of the signed region</td></tr>
<tr><td>12</td><td>pad</td><td>Padding</td><td>0-pad up to 4096 bytes</td></tr>
</tbody></table>
<p>The signed region has the following format:</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>len(payload)</td><td>Payload</td><td>The signed payload (loader or kernel)</td></tr>
<tr><td>len(payload)</td><td>4</td><td>Version</td><td>A repeat of the version number of the signature record</td></tr>
<tr><td>len(payload)+4</td><td>4</td><td>Length</td><td>len(payload) + 4 = length of all the data up to this point</td></tr>
</tbody></table>
<p>Exactly every byte in the signed region, including the Version and Length, are signed. By including the Version and Length field in the signed region, we can mitigate downgrade and length extension attacks.</p>
<p>Signatures are computed using the <a href="https://github.com/dalek-cryptography/ed25519-dalek">Dalek Cryptography Ed25519</a> crate.</p>
<p>The public key used to check the signature can come from one of three sources:</p>
<ol>
<li>A self-generated key. This is the &quot;most trusted&quot; source. Ultimately, every device should self-sign its code.</li>
<li>A third-party key. We do not handle the thorny issue of who provides the third party key, or how we come about to trust it.</li>
<li>A developer key. This is a &quot;well known&quot; key which anyone can use to sign an image.</li>
</ol>
<p>The loader will attempt to verify the kernel image, in sequence, with each of the three keys. If it fails to find any image that matches, it prints an error message to the display and powers the system down after a short delay.</p>
<p>If the image is signed with anything but the self-generated key, a visible marker (a set of fine dashed lines over the status bar) is turned on, so that users are aware that there could be a potential trust issue with the boot images. This can be rectified by re-computing a self-signature on the images, and rebooting.</p>
<p>Upon the conclusion of the signature check, the loader also does a quick check of the stack usage, to ensure that nothing ran out of bounds. This is important because the Kernel assumes that no memory pages are modified across a suspend/resume, except for the (currently) two pages of RAM allocated to the loader's stack.</p>
<h2><a class="header" href="#reading-initial-configuration" id="reading-initial-configuration">Reading Initial Configuration</a></h2>
<p>The loader needs to know basic information about the Arguments structure before it can begin. This includes information about the memory layout, extra memory regions, kernel offset, and the number of initial programs.</p>
<p>The loader performs one pass through the Arguments structure to ensure that it contains the required fields before continuing.</p>
<h2><a class="header" href="#loader-stage-1-accounting" id="loader-stage-1-accounting">Loader Stage 1: Accounting</a></h2>
<p>The first stage goes through the Arguments structure and does initial accounting. This involves multiple passes over the arguments structure.</p>
<h3><a class="header" href="#runtime-page-tracker" id="runtime-page-tracker">Runtime Page Tracker</a></h3>
<p>The first pass sets up the <em>Runtime Page Tracker</em>. Each valid page in the system can be assigned to exactly one process. Memory that does not have an entry in the <em>Runtime Page Tracker</em> cannot be allocated, preventing us from allowing aliased memory.</p>
<p>Each page in main memory as well as each page in memory-mapped IO will get one byte of data in the <em>Runtime Page Tracker</em>. This byte indicates the process ID that the memory is assigned to. Process ID <code>0</code> is invalid, and indicates the page is free.</p>
<p>Whenever a page is allocated in the loader, it is marked in this region as belonging to the kernel -- i.e. PID 1. This region is passed to the kernel which will continue to use it to keep track of page allocations.</p>
<p>This memory is zeroed out and will be filled in later.</p>
<h3><a class="header" href="#process-allocation" id="process-allocation">Process Allocation</a></h3>
<p>The loader allocates a set of initial processes, and it must pass this list of processes to the kernel. Fundamentally a process is just three things:</p>
<ol>
<li>A memory space</li>
<li>An entrypoint</li>
<li>A stack</li>
</ol>
<p>As such, the loader needs to allocate a table with these three pieces of information that is large enough to fit all of the initial processes. Therefore, it allocates a slice of memory that contains an <code>InitialProcess</code> struct that is big enough to cover all of the initial processes.</p>
<p>This structure is zeroed out, and will be filled in later.</p>
<h3><a class="header" href="#argument-copying" id="argument-copying">Argument Copying</a></h3>
<p>The Arguments structure may be in RAM, but it may be located in some other area that will become inaccessible when the system is running. If configured, the Arguments structure is copied into RAM.</p>
<h3><a class="header" href="#process-copying" id="process-copying">Process Copying</a></h3>
<p>Each process, plus the kernel, is then copied into RAM.</p>
<p>This is complex due to how memory data is laid out. For example, some sections are labeld NOCOPY, and indicate data such as <code>.bss</code> where there is no actual data to copy, it must simply be zeroed out.</p>
<h3><a class="header" href="#setting-page-ownership" id="setting-page-ownership">Setting page ownership</a></h3>
<p>Mark all loader pages as being owned by <code>PID 1</code>. This ensures they cannot be reallocated later on.</p>
<h2><a class="header" href="#loader-stage-2-setting-page-tables" id="loader-stage-2-setting-page-tables">Loader Stage 2: Setting Page Tables</a></h2>
<p>Now that memory has been copied, the second stage is responsible for parsing the loader file and setting up the system-specific page tables.</p>
<p>The loader walks the Arguments structure again and loops through each initial process as well as the kernel. For each process, it allocates the root page table, sets up the various memory sections with their requested permissions, allocates a stack, and marks all memory as loaded by the correct process.</p>
<p>After this is done, the loader maps all of the loader-specific sections into the kernel's memory space. In particular, the following are all mapped directly:</p>
<ul>
<li>Arguments structure</li>
<li>Initial process list</li>
<li>Runtime page tracker</li>
</ul>
<h2><a class="header" href="#jumping-to-the-kernel" id="jumping-to-the-kernel">Jumping to the Kernel</a></h2>
<p>The loader runs in Machine mode, which means the MMU is disabled. As soon as the loader jumps to the kernel, the CPU enters Supervisor mode with the MMU enabled and never again returns to Machine mode.</p>
<p>The loader stashes these settings in a structure called <code>backup_args</code>. This structure is currently placed at the end of loader stack, however in the future it may be allocated alongside structures such as the runtime page tracker.</p>
<p>Execution continues in <code>start_kernel</code>, which is located in <code>asm.S</code>.</p>
<p>In order to allow interrupts and exceptions to be handled by the kernel, the loader sets <code>mideleg</code> to <code>0xffffffff</code> in order to delegate all interrupts to Supervisor mode, and it sets <code>medeleg</code> to <code>0xffffffff</code> in order to delegate all CPU exceptions to the kernel.</p>
<p>The loader then does the handover by setting <code>mepc</code> and issuing a <code>reti</code> Return from Interrupt opcode.</p>
<h2><a class="header" href="#resuming-from-suspend" id="resuming-from-suspend">Resuming from Suspend</a></h2>
<p>The operating system supports resuming from a cold poweroff. In order to get into this state, a program in the operating system wrote some values into RAM, then issued a command to power of the CPU in the middle of an interrupt handler.</p>
<p>A system is considered to be suspended when RAM contains a valid group of murmur3-signed hashes located at the 3rd page from the end of memory. If these hashes match, then the system is considered to be in suspend.</p>
<p>The loader then skips all remaining setup, beacuse setup was previously performed and the system is in a live state. Indeed, if the loader tried to set up the data section of proceses again, it would overwrite any volatile data in RAM.</p>
<p>In order to resume, the loader triggers a <code>STATE_RESUME</code> interrupt. This interrupt is not handled yet, since interrupts are not enabled. Instead, this interrupt will stay triggered until the kernel unmasks them, at which point the kernel will resume execution in the <code>susres</code> server and process the resume.</p>
<p>It then calls the kernel with arguments similar to a full boot. It reads values from the <em>backup_args</em> array located at the bottom of stack.</p>
<p>There is one change, however. Instead of beginning inside the kernel <em>main</em> function, the kernel begins executing immediately at the previous process. This causes the kernel to skip its initialization, and the kernel will resume where it left off once the preemption timer resumes.</p>
<h1><a class="header" href="#minielf-file-format" id="minielf-file-format">MiniELF File Format</a></h1>
<p>The loader uses a miniature version of the ELF file format.</p>
<p>ELF files support multiple sections. These sections have various flags, and may contain executable code, data, nothing, or debug information.</p>
<p>Traditional embedded programming relies on linker scripts to copy executable code into a format that can be programmed. Because Xous utilises an MMU, we can use ELF files natively.</p>
<p>A problem with the ELF format is that it contains a lot of overhead. The miniaturised version used here reduces the file size considerably while making it easier for the program to be loaded.</p>
<h2><a class="header" href="#program-header" id="program-header">Program Header</a></h2>
<p>The program header contains just two pieces of information: The <em>load_offset</em>, and the <em>entrypoint</em>.</p>
<p>The <em>load_offset</em> is the offset, relative to the start of the Arguments structure, where various sections are stored. That is, if a section indicates that it is loading from address <code>0x100</code>, then the actual physical address can be calculated as:</p>
<ul>
<li><code>0x100</code> * offset_of(arguments_list) + minielf.load_offset</li>
</ul>
<p>The <em>entrypoint</em> is simply the value of the program counter when the program is first started.</p>
<h2><a class="header" href="#section-headers" id="section-headers">Section Headers</a></h2>
<p>Following the Program Header is one or more Section Headers. The ELF format supports multiple section types, and does not have a fixed data/text/bss split, instead preferring a series of flags and values. The Xous image creation process opens the ELF file for each initial program and scans its section list. It skips any section that isn't required for running -- for example, symbol names, compile-time information, and debug information.</p>
<p>If a section is required for running and has no data -- for example if it's a <code>.bss</code> section -- then it sets the <code>NOCOPY</code> flag. Otherwise, data will get copied.</p>
<p>It then sets the <code>EXECUTE</code> and/or <code>WRITE</code> flags according to the ELF header.</p>
<p>Finally, it creates a new section entry in the Arguments structure with the specified flags, offset, and size. The offset used here is relative to the start of the output image on disk. Therefore, the very first section to be written will have an offset of <code>0</code>.</p>
<h2><a class="header" href="#elf-flags" id="elf-flags">ELF Flags</a></h2>
<p>ELF supports multiple flags. For example, it is possible to mark a section as <code>Executable</code>, <code>Read-Only</code>, or <code>Read-Write</code>. Unfortunately these flags don't work well in practice, and issues can arise from various permissions problems.</p>
<p>Xous currently marks all pages <code>Read-Write-Execute</code>, however this may change in the future.</p>
<h2><a class="header" href="#flattened-minielf" id="flattened-minielf">Flattened MiniELF</a></h2>
<p>The flattened MiniELF format is currently theoretical. This format would expand the on-disk representation of a process such that it was page-aligned. For example, in the storage format, offset <code>0x100</code> may be loaded to memory location <code>0x20000000</code>, while offset <code>0x110</code> may be loaded to offset <code>0x40000000</code>. The MMU is unable to create such fine-grained mappings, however a <code>Flattened MiniELF</code> file would reorder this such that the first memory location is stored at offset <code>0x1000</code> on the disk, allowing that entire page to be mapped to offset <code>0x20000000</code>. Padding will be added, and the subsequent data would be stored at offset <code>0x2000</code>. This allows the next page to be cleanly mapped to <code>0x40000000</code>.</p>
<p>This format will allow Execute-in-Place from SPI flash, which will free up additional memory.</p>
<h1><a class="header" href="#xous-build-system-overview" id="xous-build-system-overview">Xous Build System Overview</a></h1>
<p>The Xous build system uses the <code>xtask</code> concept to perform complex tasks without needing an external build system.</p>
<p>The <code>xtask</code> concept is simply an alias under <code>.cargo/config</code> that turns <code>cargo xtask</code> into <code>cargo run --package xtask --</code>.</p>
<p>Therefore, all complex operations from building the kernel to constructing an output image are handled by <code>xtask/src/main.rs</code>, which is compiled and run as a normal Rust program.</p>
<h2><a class="header" href="#building-images" id="building-images">Building Images</a></h2>
<p>Generally, users will want to use <code>cargo xtask app-image [app 1] [app ..]</code> to build a Xous image that contains the desired list of applications. The applications are the names of crates contained in the &quot;apps/&quot; directory.</p>
<p>There are also convenience commands to build emulation images, such as <code>cargo xtask run</code> (for hosted mode, where Xous runs directly on your native OS) and <code>cargo xtask renode-image</code> (for a Renode image, where a cycle accurate simulation can be run inside the Renode emulator). See Chapter 4 for more information about Renode.</p>
<h2><a class="header" href="#the-internal-flow-of-the-build-system" id="the-internal-flow-of-the-build-system">The Internal Flow of the Build System</a></h2>
<p>For those curious as to what the builder does on the inside, here is the general flow of most build operations.</p>
<h3><a class="header" href="#step-0-build-the-build-system" id="step-0-build-the-build-system">Step 0: Build the Build System</a></h3>
<p>When you type <code>cargo xtask</code>, the build system will compile <code>xtask/src/main.rs</code>. This happens automatically.</p>
<h3><a class="header" href="#step-1-build-the-kernel" id="step-1-build-the-kernel">Step 1: Build the Kernel</a></h3>
<p>The build system runs <code>cargo build --package kernel --release --target riscv32imac-unknown-xous-elf</code> in the <code>kernel/</code> directory.</p>
<h3><a class="header" href="#step-2-build-the-initial-programs" id="step-2-build-the-initial-programs">Step 2: Build the Initial Programs</a></h3>
<p>The build system runs <code>cargo build --target riscv32imac-unknown-xous-elf</code> with every initial program appended as a <code>--package</code> argument.</p>
<h3><a class="header" href="#step-3-build-the-loader" id="step-3-build-the-loader">Step 3: Build the Loader</a></h3>
<p>The build system runs <code>cargo build --target riscv32imac-unknown-xous-elf --package loader</code> in the <code>loader/</code> directory.</p>
<h3><a class="header" href="#step-4-package-it-all-up" id="step-4-package-it-all-up">Step 4: Package it all Up</a></h3>
<p>The build system runs <code>cargo run --package tools --bin create-image --</code> followed by arguments to create the mage.</p>
<h1><a class="header" href="#xous-image-creation" id="xous-image-creation">Xous Image Creation</a></h1>
<p>Xous image creation is primarily performed by the <code>create-image</code> program. This program bundles memory definitions, the kernel, and initial programs together and generates an image on-disk suitable for passing to the loader.</p>
<p>You can run this program manually to see how it works:</p>
<pre><code class="language-sh">$ cargo run -p tools --bin create-image -- --help
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
     Running `target/debug/create-image --help`
Xous Image Creator 0.1.0
Sean Cross &lt;sean@xobs.io&gt;
Create a boot image for Xous

USAGE:
    create-image [FLAGS] [OPTIONS] &lt;OUTPUT&gt; --csv &lt;CSR_CSV&gt; --kernel &lt;KERNEL_ELF&gt; --ram &lt;OFFSET:SIZE&gt; --svd &lt;SOC_SVD&gt;

FLAGS:
    -d, --debug      Reduce kernel-userspace security and enable debugging programs
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -c, --csv &lt;CSR_CSV&gt;          csr.csv file from litex
    -i, --init &lt;init&gt;...         Initial program to load
    -k, --kernel &lt;KERNEL_ELF&gt;    Kernel ELF image to bundle into the image
    -r, --ram &lt;OFFSET:SIZE&gt;      RAM offset and size, in the form of [offset]:[size]
    -s, --svd &lt;SOC_SVD&gt;          soc.csv file from litex

ARGS:
    &lt;OUTPUT&gt;    Output file to store tag and init information
$
</code></pre>
<p>This program generates an <a href="ch05-01-arguments.html">Arguments structure</a> based on the specified commands, and copies data from the given ELF files into an area immediately following this structure. In this manner, a complete, position-independent loadable system is generated in a single binary image.</p>
<p>This program also does rudimentary sanity checking. For example, it will ensure the kernel is loaded at a sane offset -- namely above address <code>0xff000000</code>. It will also ensure the memory regions don't overlap.</p>
<p>As a special case, it will trim the CSR section down from the reported size. In essence, while the configuration region is defined as 256 MB wide, this large region is never used in practice. In order to reduce the amount of memory required to store this data, as well as in order to remove memory aliasing attacks, the CSR region is trimmed down from the reported value to only encompass ranges that are valid.</p>
<h2><a class="header" href="#the-kernel-and-initial-programs" id="the-kernel-and-initial-programs">The Kernel and Initial Programs</a></h2>
<p>The kernel, as well as each initial program, are all packaged together in the same <code>args.bin</code> file. In order to do this, <code>create-image</code> operates in a two-pass fashion.</p>
<p>To begin with, all tags are created and lumped together. This is done first by calling <code>finalize()</code> on each tag, followed by writing them all out to disk. The <code>finalize()</code> call allows tags to update internal fields, but does not allow tags to change their size at all.</p>
<p>The <code>finalize()</code> argument takes a single argument, which describes how many additional bytes have been added to the args structure. This function may do nothing, in which case it returns zero. It may also request that additional data be added to the output, in which case it should return a nonzero value.</p>
<p>After all tags have been written, the <code>last_data()</code> function is called for each tag. This allows the tag to append data to the end of the structure.</p>
<p>An example of tags that do this include the kernel and the initial programs. They return the size of their payload in the <code>finalize()</code> call. They also use this call to update the tag data prior to writing it out.</p>
<p>They also write the actual contents of the tag during the <code>last_data()</code> call.</p>
<h1><a class="header" href="#messages-and-message-passing" id="messages-and-message-passing">Messages and Message Passing</a></h1>
<p>Messages form the basis of interprocess communication on Xous. A process exists in isolation and can only communicate to the outside world by sending messages. The limited API provided by the kernel means that almost all interactions are provided by userspace Servers, which must be communicated with using Messages.</p>
<h2><a class="header" href="#connecting-to-and-disconnecting-from-servers" id="connecting-to-and-disconnecting-from-servers">Connecting to and Disconnecting from Servers</a></h2>
<p>To connect to a server you must supply it an <code>Server ID</code>. A <code>Server ID</code> is a 16-byte value of some sort that is shared in a universal namespace. If you know a Server's <code>Server ID</code> then you can connect to that Server.</p>
<p>There are a few well-known <code>Server ID</code>s. These include bare minimum IDs that are required by any process to do anything useful. They are:</p>
<ul>
<li><em>b&quot;xous-log-server &quot;</em>: Output log messages to the console, as well as basic <code>println!()</code> support</li>
<li><em>b&quot;ticktimer-server&quot;</em>: Used for <code>sleep()</code> as well as time-based Mutexes</li>
<li><em>b&quot;xous-name-server&quot;</em>: A central nameserver that is used for connecting to all other servers</li>
</ul>
<p>To connect to a Server, call <code>xous::connect()</code>. For example, to connect to the <code>ticktimer-server</code>, call:</p>
<pre><code class="language-cs">let connection_id = xous::connect(xous::SID::from_bytes(b&quot;ticktimer-server&quot;).unwrap())?;
</code></pre>
<p>This will provide you a Connection to that server. If the Server is not available, the call will block until it is created. To fail if the server does not exist, use <code>try_connect()</code> instead of <code>connect()</code>.</p>
<h2><a class="header" href="#connection-limitations" id="connection-limitations">Connection Limitations</a></h2>
<p>Connections are limited on a per-process basis. Each process may only establish a connection to at most 32 servers. When this number is exceeded, <code>xous::connect()</code> will return <code>Error::OutOfMemory</code>.</p>
<p>If you call <code>xous::connect()</code> twice with the same <code>Server ID</code>, then you will get the same <code>connection_id</code>.</p>
<h2><a class="header" href="#disconnecting" id="disconnecting">Disconnecting</a></h2>
<p>To disconnect from a server, call <code>unsafe { xous::disconnect(connection_id)};</code>. This function is <code>unsafe</code> because you can copy connection IDs, so it is up to you to ensure that they are no longer in use when disconnecting.</p>
<p>For example, if you <code>connect()</code> to a Server and spawn a thread with that connection ID, you should only call <code>disconnect()</code> once that thread has finished with the connection. Similarly, if you <code>Copy</code> the connection ID to the thread, you must make sure that <strong>both</strong> uses of the Connection ID are destroyed prior to disposing of the connection.</p>
<p>Because of this, it is recommended that you use an <code>ARC&lt;CID&gt;</code> in order to ensure that the connection is only closed when it is no longer in use.</p>
<p>Furthermore, recall that subsequent calls to <code>connect()</code> with the same argument will reuse the <code>connection_id</code>. Because of this, it is vital that you only call <code>disconnect()</code> when you are certain that all instances are finished with the connection.</p>
<h2><a class="header" href="#message-overview" id="message-overview">Message Overview</a></h2>
<p>Messages come in five kinds: Scalar, BlockingScalar, Borrow, MutableBorrow, and Send. <code>Scalar</code> and <code>Send</code> messages are nonblocking and return immediately, while the others wait for the Server to respond.</p>
<p><code>Borrow</code>, <code>MutableBorrow</code>, and <code>Send</code> all detach memory from the client and send it to the server.</p>
<h2><a class="header" href="#scalar-and-blockingscalar-messages" id="scalar-and-blockingscalar-messages">Scalar and BlockingScalar Messages</a></h2>
<p>These messages allow for sending four <code>usize</code>s of data plus one <code>usize</code> of command. This can be used to send short updates to the Server. <code>Scalar</code> messages return to the client immediately, meaning the Server will receive the message after a short delay.</p>
<p><code>BlockingScalar</code> messages will pause the current thread and switch to the Server immediately. If the message is handled quickly, the Server can respond to the message and switch back to the Client before its quantum expires.</p>
<p><code>BlockingScalar</code> messages can return one or two <code>usize</code>s worth of data by returning <code>Result::Scalar1(usize)</code> or <code>Result::Scalar2(usize, usize)</code>.</p>
<p>As an example of what can be done, the ticktimer server uses <code>BlockingScalar</code> messages to implement <code>msleep()</code> by delaying the response until a timer expires.</p>
<h2><a class="header" href="#borrow-mutableborrow-and-send-messages" id="borrow-mutableborrow-and-send-messages">Borrow, MutableBorrow, and Send Messages</a></h2>
<p>These messages allow for sending memory from one process to another. Memory must be page-sized and aligned, but may be any memory available to a process. For example, a hardware process may want to reserve all MMIO peripherals in the system and then share them with processes as desired.</p>
<p>The memory message types allow for one <code>usize</code> worth of tag data which can be used to describe what the message is used for.</p>
<p>Furthermore, messages may also contain two advisory fields: <code>offset</code> and <code>valid</code>. These fields may be used to define an offset with the memory block where interesting data occurs. Similarly, the <code>valid</code> field could be used to define how large the data is.</p>
<p>When memory is passed via <code>MutableBorrow</code> then the memory is mapped into the Server's address space as writable. Addtionally, the <code>offset</code> and <code>valid</code> fields become writable and may be updated in the server. As an example, if a Server implemented <code>bzero()</code> to clear a memory range to zero, then it might clear the contents of the buffer, then set both <code>offset</code> and <code>valid</code> to 0.</p>
<p>Internally, the <code>MutableBorrow</code> is updated by passing the new fields to <code>ReturnMemory()</code> where it gets updated in the client.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
