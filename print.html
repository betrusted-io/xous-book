<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Xous Operating System</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Xous Operating System</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-renode.html"><strong aria-hidden="true">1.3.</strong> Hello, Renode!</a></li><li class="chapter-item expanded "><a href="ch01-04-hello-hardware.html"><strong aria-hidden="true">1.4.</strong> Hello, Hardware!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-server-architecture.html"><strong aria-hidden="true">2.</strong> Server Architecture</a></li><li class="chapter-item expanded "><a href="ch03-00-introducing-the-kernel.html"><strong aria-hidden="true">3.</strong> Introducing the Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-memory-layout.html"><strong aria-hidden="true">3.1.</strong> Memory Layout</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-renode-emulation.html"><strong aria-hidden="true">4.</strong> Renode Emulation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-platform-definition.html"><strong aria-hidden="true">4.1.</strong> Platform Definition</a></li><li class="chapter-item expanded "><a href="ch04-02-renode-startup-script.html"><strong aria-hidden="true">4.2.</strong> Renode Startup Script</a></li><li class="chapter-item expanded "><a href="ch04-03-python-extensions.html"><strong aria-hidden="true">4.3.</strong> Python Extensions</a></li><li class="chapter-item expanded "><a href="ch04-04-writing-cs-peripherals.html"><strong aria-hidden="true">4.4.</strong> Writing C# Peripherals</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Xous Operating System</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/betrusted-io/xous-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-xous-operating-system" id="the-xous-operating-system">The Xous Operating System</a></h1>
<p><em>by Sean &quot;xobs&quot; Cross and Andrew &quot;bunnie&quot; Huang, with contributions from the Rust Community</em></p>
<p>This version of the text assumes you’re using Rust 1.54 with the Xous library
installed.</p>
<h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<h1><a class="header" href="#hello-world" id="hello-world">Hello, World!</a></h1>
<h1><a class="header" href="#hello-renode" id="hello-renode">Hello, Renode!</a></h1>
<h1><a class="header" href="#hello-hardware" id="hello-hardware">Hello, Hardware!</a></h1>
<h1><a class="header" href="#server-architecture" id="server-architecture">Server Architecture</a></h1>
<h1><a class="header" href="#introducing-the-kernel" id="introducing-the-kernel">Introducing the Kernel</a></h1>
<h1><a class="header" href="#memory-management-in-xous" id="memory-management-in-xous">Memory Management in Xous</a></h1>
<p>Memory is allocated with the <code>MapMemory</code> syscall. This call accepts four arguments:</p>
<ul>
<li>physical: <code>Option&lt;NonZeroUsize&gt;</code>: The physical address you would like to allocate. Specify <code>None</code> if you don't need a particular address.</li>
<li>virtual: <code>Option&lt;NonZeroUsize&gt;</code>: The virtual address you would like to allocate. Specify <code>None</code> if you don't need a particular virtual address.</li>
<li>size: <code>NonZeroUsize</code>: The size of the region to allocate. This must be page-aligned.</li>
<li>flags: <code>MemoryFlags</code>: A list of platform-specific flags to apply to this region.</li>
</ul>
<p>The memory will return a <code>MemoryRange</code> that encompasses the given region.</p>
<p>You can free memory with <code>UnmapMemory</code>, though be very careful not to free memory that is currently in use. <code>UnmapMemory</code> simply takes the <code>MemoryRange</code> returned by <code>MapMemory</code>.</p>
<h2><a class="header" href="#physical-addresses" id="physical-addresses">Physical Addresses</a></h2>
<p>A program rarely needs to access physical addresses, and in most operating systems it's not the kind of thing you can actually <em>do</em>. However, Xous is designed to be embedded, so it's entirely legal to request a physical address.</p>
<p>The trick is that you can only request physical addresses that actually exist. For example, you cannot request a physical address for a mirrored region of a peripheral because that is not a valid address.</p>
<p><strong>If you request a physical address from main RAM, the memory will be zeroed when you receive it</strong>. Peripherals and ares that are not in main RAM will not be zeroed. It is for this reason that system services are recommended to claim all peripherals before running user programs.</p>
<h2><a class="header" href="#virtual-addresses" id="virtual-addresses">Virtual Addresses</a></h2>
<p>All Xous programs run with virtual memory enabled. Attempting to perform an illegal operation will result in an exception. If you have an exception handler installed, illegal memory accesses will run this exception handler which may fixup the exception.</p>
<h3><a class="header" href="#demand-paging" id="demand-paging">Demand Paging</a></h3>
<p>When you allocate memory using <code>MapMemory(None, None, ..., ...)</code>, you will be handed memory from the <code>DEFAULT_BASE</code>. This memory will not be backed by a real page, and will only be allocated by the kernel once you access the page. This allows threads to allocate large stacks without running out of memory immediately.</p>
<p>Pages that are mapped-but-unallocated are visible in a process' page table view. As an example, consider the following excerpt from a page table view:</p>
<pre><code class="language-text">    38 60026000 -&gt; 400a3000 (flags: VALID | R | W | USER | A | D)
    41 60029000 -&gt; 40108000 (flags: VALID | R | W | A | D)
    42 6002a000 -&gt; 40109000 (flags: VALID | R | W | A | D)
    43 6002b000 -&gt; 00000000 (flags: R | W)
    44 6002c000 -&gt; 00000000 (flags: R | W)
</code></pre>
<p>Addresses 0x60026000 (#38), 0x60029000 (#41), and 0x6002a000 (#42) are all allocated. The rest of the pages are valid-but-unallocated.</p>
<p>Address 0x60026000 (#38) is mapped to the process and has a valid physical address. Reads and writes to this page are backed by physical address 0x400a3000.</p>
<p>Addresses 0x60029000 (#41) and 0x6002a000 (#42) are still owned by the kernel, likely because they were being cleared.</p>
<p>Addresses 0x6002b000 (#43) and 0x6003c000 (#44) are on-demand allocated. They have no physical backing, and attempting to access them will result in a kernel fault where they will be allocated. When the page is allocated, it will be given the flags <code>R | W</code> in addition to default kernel flags.</p>
<h3><a class="header" href="#the-heap" id="the-heap">The Heap</a></h3>
<p>When we talk about &quot;The Heap&quot; we mean data that is managed by functions such as <code>malloc</code>. Xous has a pair of syscalls that behave vaguely like the Unix <code>brk</code> command.</p>
<p><code>IncreaseHeap(usize, MemoryFlags)</code> will increase a program's heap by the given amount. This returns the new heap as a <code>MemoryRange</code>.</p>
<p>To decrease the heap by a given amount, call <code>DecreaseHeap(usize)</code>.</p>
<p>Note that you must adjust the heap in units of <code>PAGE_SIZE</code>.</p>
<p>You can avoid using these syscalls by manually allocating regions using <code>MapMemory</code>, however they are a convenient abstraction with their own memory range.</p>
<p><code>liballoc</code> as bundled by Xous uses these syscalls as a backing for memory.</p>
<h3><a class="header" href="#virtual-memory-regions" id="virtual-memory-regions">Virtual Memory Regions</a></h3>
<p>There are different memory regions in virtual address space:</p>
<table><thead><tr><th>Address</th><th>Name</th><th>Variable</th><th>Description</th></tr></thead><tbody>
<tr><td>0x00010000</td><td>text</td><td>-</td><td>Start of <code>.text</code> with the default riscv linker script (<code>riscv64-unknown-elf-ld -verbose</code>)</td></tr>
<tr><td>0x20000000</td><td>heap</td><td>DEFAULT_HEAP_BASE</td><td>Start of the heap section returned by <code>IncreaseHeap</code></td></tr>
<tr><td>0x40000000</td><td>message</td><td>DEFAULT_MESSAGE_BASE</td><td>Base address where <code>MemoryMessage</code> messages are mapped inside of a server</td></tr>
<tr><td>0x60000000</td><td>default</td><td>DEFAULT_BASE</td><td>Default region when calling `MapMemory(..., None, ..., ...) -- most threads have their stack here</td></tr>
<tr><td>0x7fffffff</td><td>stack</td><td>-</td><td>The default stack for the first thread - grows downwards</td></tr>
<tr><td>0xff000000</td><td>kernel</td><td>USER_AREA_END</td><td>The end of user area and the start of kernel area</td></tr>
<tr><td>0xff400000</td><td>pgtable</td><td>PAGE_TABLE_OFFSET</td><td>A process' page table is located at this offset, accessible only to the kernel</td></tr>
<tr><td>0xff800000</td><td>pgroot</td><td>PAGE_TABLE_ROOT_OFFSET</td><td>The root page table is located at this offset, accessible only to the kernel</td></tr>
</tbody></table>
<p>In addition, there are special addresses that indicate the end of a function. The kernel will set these as the return address for various situations, and they are documented here for completeness:</p>
<table><thead><tr><th>Address</th><th>Name</th><th>Variable</th><th>Description</th></tr></thead><tbody>
<tr><td>0xff802000</td><td>retisr</td><td>RETURN_FROM_ISR</td><td>Indicates the return from an interrupt service routine</td></tr>
<tr><td>0xff803000</td><td>exitthr</td><td>EXIT_THREAD</td><td>Indicates a thread should exit</td></tr>
<tr><td>0xff804000</td><td>retex</td><td>RETURN_FROM_EXCEPTION_HANDLER</td><td>Indicates the return from an exception handler</td></tr>
</tbody></table>
<h1><a class="header" href="#renode-emulation" id="renode-emulation">Renode Emulation</a></h1>
<p><a href="https://renode.io/">Renode</a> is a multi-device emulator written in C#. It is designed to assist in testing and development of software, and is also useful in developing new hardware blocks.</p>
<p>The emulator is available for Windows, Mac, and Linux. It is designed to simulate whole systems of devices, meaning it can easily capture the interactions between devices on a network or bus. It allows you to pause the system and inspect memory, single-step, and watch various sections of the bus.</p>
<p>There is extensive end-user documentation available at <a href="https://renode.readthedocs.io/en/latest/">readthedocs</a>, which is highly recommended. The remainder of this chapter will cover recommendations on how to use Renode with Xous.</p>
<h1><a class="header" href="#writing-renode-c-peripherals" id="writing-renode-c-peripherals">Writing Renode C# Peripherals</a></h1>
<p>Renode is written in C#, which means it has access to the entire base of C#. One feature of C# is the <code>CSharpCodeProvider</code> object which provides the <code>CompileAssemblyFromSource(CompilerParameters, string[])</code> function. This means that Renode has a runtime C# compiler built in.</p>
<p>You can <code>include</code> C# files in the Renode console or in your startup script to dynamically add new peripherals to your environment. Xous uses this extensively in Betrusted since the hardware peripherals are still under development and therefore change regularly. Updating a hardware module in Renode simply involves modifying the <code>.cs</code> file and restarting Renode. There is no additional compile step.</p>
<h2><a class="header" href="#setting-up-an-ide----visual-studio-code" id="setting-up-an-ide----visual-studio-code">Setting up an IDE -- Visual Studio Code</a></h2>
<p>It is highly recommended to use a full IDE. The Renode API can change, and it can take time to restart Renode to recompile your C# files. An IDE will provide you with tab-completion and will immediately tell you if there is a code error.</p>
<p>The core of Renode is written in a full IDE such as Visual Studio or Monodevelop. These IDEs expect a full Project file that defines a single target output -- for example an executable or a linked library. With our usage of C# there is no single target since Renode will dynamically load the source files. To work around this, we create a stub project file that tricks the IDE into loading our assembly files and providing autocomplete. We never actually <em>use</em> this project file, but it's used behind the scenes automatically.</p>
<p>Broadly speaking, there are three steps to setting up an IDE:</p>
<ol>
<li>Download Visual Studio Code</li>
<li>Copy the reference project file</li>
<li>Modify the reference project file</li>
<li>Install the C# extension.</li>
</ol>
<p>To begin with download <a href="https://code.visualstudio.com/">Visual Studio Code</a>. It is available for Windows, Linux, and Mac.</p>
<p>Next, copy <code>emulation/peripherals.csproj.template</code> to <code>emulation/peripherals.csproj</code>. This is a C# Project file that is understood by Visual Studio and Visual Studio Code. The file name <code>peripherals.csproj</code> is in the <code>.gitignore</code> file, so don't worry about accidentally checking it in.</p>
<p>Edit <code>peripherals.csproj</code> and modify <code>RenodePath</code> to point to your Renode installation where the <code>.dll</code> files are located. On Linux this is likely <code>/opt/renode/bin</code>. On Windows this may be in <code>C:\Program Files\</code>.</p>
<p>Finally, install the <a href="https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp">C# for Visual Studio Code</a> extension. This extension will activate, parse your <code>.csproj</code>, and start providing autocomplete and compile suggestions.</p>
<h2><a class="header" href="#creating-a-new-peripheral" id="creating-a-new-peripheral">Creating a new Peripheral</a></h2>
<p>To create a new peripheral, simply copy an existing peripheral to a new filename under <code>emulation/peripherals/</code>, making sure the filename ends in <code>.cs</code>.</p>
<p>Many examples exist in the <code>emulation/peripherals/</code> directory, and you can find many more examples <a href="https://github.com/renode/renode-infrastructure/tree/master/src/Emulator/Peripherals/Peripherals">built into Renode</a>.</p>
<p>A simple example could be a device that provides random numbers:</p>
<pre><code class="language-cs">using Antmicro.Renode.Core;
using Antmicro.Renode.Core.Structure.Registers;
using Antmicro.Renode.Logging;

namespace Antmicro.Renode.Peripherals.Miscellaneous
{
    public class ExampleRNGServer : BasicDoubleWordPeripheral, IKnownSize
    {
        public long Size { get { return 0x100; } }
        public GPIO IRQ { get; private set; }
        private readonly PseudorandomNumberGenerator rng = EmulationManager.Instance.CurrentEmulation.RandomGenerator;
        private bool enabled = true;

        private enum Registers
        {
            CONTROL = 0x0,
            DATA = 0x4,
            STATUS = 0x8,
            AV_CONFIG = 0xc,
            RO_CONFIG = 0x10,

            READY = 0xc4,
            EV_STATUS = 0xc8,
            EV_PENDING = 0xcc,
            EV_ENABLE = 0xd0,
            URANDOM = 0xdc,
            URANDOM_VALID = 0xe0,
            TEST = 0xf8,
        }

        public ExampleRNGServer(Machine machine) : base(machine)
        {
            this.IRQ = new GPIO();
            DefineRegisters();
        }


        private void DefineRegisters()
        {

            Registers.URANDOM.Define(this)
                .WithValueField(0, 32, FieldMode.Read, valueProviderCallback: _ =&gt;
                {
                    if (!enabled)
                        return 0;
                    return (uint)rng.Next();
                }, name: &quot;URANDOM&quot;);
            Registers.DATA.Define(this)
                .WithValueField(0, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
                {
                    if (!enabled)
                        return 0;
                    return (uint)rng.Next();
                }, name: &quot;DATA&quot;)
                .WithValueField(16, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
                {
                    return 0xf00f;
                }, name: &quot;SIGNATURE&quot;);
            Registers.URANDOM_VALID.Define(this)
                .WithFlag(0, FieldMode.Read, valueProviderCallback: _ =&gt; { return true; }, name: &quot;URANDOM_VALID&quot;)
                .WithFlag(1, FieldMode.Read, valueProviderCallback: _ =&gt; { return enabled; }, name: &quot;ENABLE&quot;);

            Registers.CONTROL.Define(this)
                .WithFlag(0, FieldMode.Write, writeCallback: (_, val) =&gt; { enabled = val; }, name: &quot;ENABLE&quot;);
        }
    }
}
</code></pre>
<p>There's a lot to take in there, particularly if you've never dealt with C# before. Let's go over the module line-by-line.</p>
<pre><code class="language-cs">using Antmicro.Renode.Core;
using Antmicro.Renode.Core.Structure.Registers;
using Antmicro.Renode.Logging;
</code></pre>
<p>The first three lines import various packages to the current namespace. You'll most likely use these in all of your projects. Any valid C# namespace may be used, including core <code>.Net</code> libraries. This can be useful if you need networking, cryptography, or other exotic libraries. There are many useful logging functions as well. You'll notice that the final line is darker than the other two. This is because this package is currently unused -- we don't perform any logging currently. You can safely remove this final line, however it's useful to leave Logging as an import because it allows for autocompletion of Logging functions.</p>
<pre><code class="language-cs">namespace Antmicro.Renode.Peripherals.Miscellaneous {
</code></pre>
<p>Next, we define the namespace for this module. The module MUST be under a <code>namespace Antmicro.Renode.Peripherals.xxx</code> namespace. In this case, it is under <code>Antmicro.Renode.Peripherals.Miscellaneous</code>. This namespacing provides a handy structure to various peripherals.</p>
<pre><code class="language-cs">public class ExampleRNGServer : BasicDoubleWordPeripheral, IKnownSize {
</code></pre>
<p>Finally, we begin to define our class. This class is named <code>ExampleRNGServer</code>, and it inherits <code>BasicDoubleWordPeripheral</code> and <code>IKnownSize</code>.</p>
<p>The <code>BasicDoubleWordPeripheral</code> class provides several convenience functions that makes it easy to create a memory-mapped device. It means we don't need to manage accessors, and we can simply worry about the register values themselves.</p>
<p>Peripherals need to have a known size, so we inform C# that our client has a known size. The <code>I</code> stands for Interface. To find out which functions we must implement to conform to <code>IKnownSize</code>, hold Ctrl and click on <code>IKnownSize</code>. It will take you to the definition of <code>IKnownSize</code>, located inside <code>Emulator.dll</code>. You will note that the only thing we need to implement is <code>log Size { get; }</code>, which means we only need to create an accessor for the property <code>Size</code>.</p>
<pre><code class="language-cs">public long Size { get { return 0x100; } }
public GPIO IRQ { get; private set; }
private readonly PseudorandomNumberGenerator rng = EmulationManager.Instance.CurrentEmulation.RandomGenerator;
private bool enabled = true;
</code></pre>
<p>Here we define our local properties and variables. We can see the <code>Size</code> property defined here. Our peripheral goes up to <code>0xf8</code>, so we return that as a constant. This is used by Renode to ensure peripherals don't overlap, and to know which peripheral to invoke when memory is accessed.</p>
<p>There is an IRQ here as well, which is a <code>GPIO</code>. The way Renode handles interrupts is by reusing GPIO pins. We can trigger an interrupt by setting this GPIO, and the system will invoke an interrupt context on the CPU.</p>
<p>Finally there is a local variable that is part of this object and not visible outside of our class.</p>
<pre><code class="language-cs">private enum Registers
{
    CONTROL = 0x0,
    DATA = 0x4,
    STATUS = 0x8,
    AV_CONFIG = 0xc,
    RO_CONFIG = 0x10,

    READY = 0xc4,
    EV_STATUS = 0xc8,
    EV_PENDING = 0xcc,
    EV_ENABLE = 0xd0,
    URANDOM = 0xdc,
    URANDOM_VALID = 0xe0,
    TEST = 0xf8,
}
</code></pre>
<p>We define an enum called <code>Registers</code>. This is simply a mapping of register names to register numbers. It is not a particularly special enum, however correct naming of the enum values will make it easier to define the register set later on. It is standard practice to define all possible registers in this enum, even if you do not implement them right away.</p>
<pre><code class="language-cs">public ExampleRNGServer(Machine machine) : base(machine)
{
    this.IRQ = new GPIO();
    DefineRegisters();
}
</code></pre>
<p>This is the constructor for our device. It takes a single argument of type <code>Machine</code>. Because we inherit from <code>BasicDoubleWordPeripheral</code>, we will need to call the constructor for the base class. To figure out what the constructor looks like, hold Ctrl and click on <code>BasicDoubleWordPeripheral</code>. We can see that the constructor for that class simply takes one argument that's a <code>Machine</code>. Therefore, the first line of our constructor should invoke the base constructor directly. Which is what we do here.</p>
<p>We create a new GPIO and assign it to the IRQ. Renode will access our <code>IRQ</code> property if it wants to watch for interrupts. If our peripheral has no interrupts we can omit the <code>IRQ</code> property.</p>
<pre><code class="language-cs">private void DefineRegisters() {
</code></pre>
<p>Finally, we invoke the <code>DefineRegisters()</code> function. It is the most complicated function in this class, however it's where most of the work is done. Let's look at each register definition in order.</p>
<pre><code class="language-cs">Registers.URANDOM.Define(this)
    .WithValueField(0, 32, FieldMode.Read, valueProviderCallback: _ =&gt;
    {
        if (!enabled)
            return 0;
        return (uint)rng.Next();
    }, name: &quot;URANDOM&quot;);
</code></pre>
<p>The <code>Define(this)</code> function comes from <code>BasicDoubleWordPeripheralExtensions</code>, which is one of the classes provided to us as a subclass of <code>BasicDoubleWordPeripheral</code>. It allows us to define a register on an enum type.</p>
<p>The <code>WithValueField()</code> function defines a value for a register across a range of values. In this case, we define a value beginning at bit 0 that is 32-bits wide. We define this register as a <code>FieldMode.Read</code> register, meaning writes will be ignored. When a device accesses this register, the <code>valueProviderCallback</code> function will be called.</p>
<p>What follows is a C# closure. The first argument is the register itself, which we ignore since we are not interested in it. Therefore, the variable is named <code>_</code>. If the block is disabled, we return 0, otherwise we return a <code>uint</code> from the class RNG provider.</p>
<p>Finally, we name the register <code>URANDOM</code>.</p>
<pre><code class="language-cs">Registers.DATA.Define(this)
    .WithValueField(0, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
    {
        if (!enabled)
            return 0;
        return (uint)rng.Next();
    }, name: &quot;DATA&quot;)
    .WithValueField(16, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
    {
        return 0xf00f;
    }, name: &quot;SIGNATURE&quot;);
</code></pre>
<p>This register contains two value fields. The first is at offset 0, and is 16-bits wide. The second is at offset 16, and is also 16-bits wide.</p>
<p>The <code>valueProviderCallback</code> function is called for each field, which avoids the need for any manual bit shifting.</p>
<p>If the peripheral is not enabled, then the <code>DATA</code> field returns 0. If it is enabled, then it returns a 16-bit random value.</p>
<p>Because of the way this register is defined, the top 16 bits will always be <code>0xf00f</code>. Therefore, the register's value will be either <code>0xf00f0000</code> or <code>0xf00fRAND</code>.</p>
<pre><code class="language-cs">Registers.URANDOM_VALID.Define(this)
    .WithFlag(0, FieldMode.Read, valueProviderCallback: _ =&gt; { return true; }, name: &quot;URANDOM_VALID&quot;)
    .WithFlag(1, FieldMode.Read, valueProviderCallback: _ =&gt; { return enabled; }, name: &quot;ENABLE&quot;);
</code></pre>
<p>This register defines two flags. The first flag is at bit 0, and the second flag is at bit 1. Flags are always one-bit boolean values, which is why the <code>valueProviderCallback</code> returns <code>true</code> instead of a <code>uint</code> like we've seen in the past. Similarly to <code>WithValueField()</code>, a <code>WithFlag</code> value will call the <code>valueProviderCallback</code> for each flag, avoiding the need to do complex shifting.</p>
<pre><code class="language-cs">Registers.CONTROL.Define(this)
    .WithFlag(4, FieldMode.Write, writeCallback: (_, val) =&gt; { enabled = val; }, name: &quot;ENABLE&quot;);
</code></pre>
<p>Finally we define the <code>CONTROL</code> register. Our implementation simply has an <code>ENABLE</code> bit at offset 4. This is the first time we've seen a <code>writeCallback</code>. This closure takes two arguments: the register itself and the written value. </p>
<h2><a class="header" href="#using-the-new-peripheral" id="using-the-new-peripheral">Using the new peripheral</a></h2>
<p>To use the new peripheral, save it in a <code>.cs</code> file, then include it in Renode. For example, if it was called <code>examplerngserver.cs</code>, you would include it in Renode by running:</p>
<pre><code class="language-text">(renode) i @examplerngserver.cs
</code></pre>
<p>You can then use the <code>Miscellaneous.ExampleRNGServer</code> peripheral in any platform definition. For example, to create a new peripheral at offset <code>0x40048000</code> in the current machine, use the <code>LoadPlatformDescriptionFromString</code> command:</p>
<pre><code class="language-text">(renode) machine LoadPlatformDescriptionFromString 'rng: Miscellaneous.ExampleRNGServer @ sysbus 0x40048000'
</code></pre>
<p>Now, any accesses to <code>0x40048000</code> will be directed to your new peripheral.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
