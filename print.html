<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Xous Operating System</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Xous Operating System</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.1.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-renode.html"><strong aria-hidden="true">1.2.</strong> Hello, Renode!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-server-architecture.html"><strong aria-hidden="true">2.</strong> Server Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-04-synchronization.html"><strong aria-hidden="true">2.1.</strong> Synchronization</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-introducing-the-kernel.html"><strong aria-hidden="true">3.</strong> Introducing the Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-memory-layout.html"><strong aria-hidden="true">3.1.</strong> Memory Layout</a></li><li class="chapter-item expanded "><a href="ch03-02-hosted-mode.html"><strong aria-hidden="true">3.2.</strong> Hosted Mode</a></li><li class="chapter-item expanded "><a href="ch03-03-process-creation.html"><strong aria-hidden="true">3.3.</strong> Process Creation</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-renode-emulation.html"><strong aria-hidden="true">4.</strong> Renode Emulation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-platform-definition.html"><strong aria-hidden="true">4.1.</strong> Platform Definition</a></li><li class="chapter-item expanded "><a href="ch04-02-renode-startup-script.html"><strong aria-hidden="true">4.2.</strong> Renode Startup Script</a></li><li class="chapter-item expanded "><a href="ch04-03-python-extensions.html"><strong aria-hidden="true">4.3.</strong> Python Extensions</a></li><li class="chapter-item expanded "><a href="ch04-04-writing-cs-peripherals.html"><strong aria-hidden="true">4.4.</strong> Writing C# Peripherals</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-system-startup.html"><strong aria-hidden="true">5.</strong> System Startup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-arguments.html"><strong aria-hidden="true">5.1.</strong> Arguments Structure</a></li><li class="chapter-item expanded "><a href="ch05-02-loader.html"><strong aria-hidden="true">5.2.</strong> Xous Loader</a></li><li class="chapter-item expanded "><a href="ch05-03-minielf.html"><strong aria-hidden="true">5.3.</strong> MiniELF Format</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-build-system-overview.html"><strong aria-hidden="true">6.</strong> Build System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-testing-crates.html"><strong aria-hidden="true">6.1.</strong> Testing Crates</a></li><li class="chapter-item expanded "><a href="ch06-02-create-image.html"><strong aria-hidden="true">6.2.</strong> Image Creation</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-messages.html"><strong aria-hidden="true">7.</strong> Messages</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-xous-names.html"><strong aria-hidden="true">7.1.</strong> Xous Names</a></li><li class="chapter-item expanded "><a href="ch07-02-caller-idioms.html"><strong aria-hidden="true">7.2.</strong> Caller Idioms</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-03-nonsynchronizing.html"><strong aria-hidden="true">7.2.1.</strong> Non-synchronizing</a></li><li class="chapter-item expanded "><a href="ch07-04-synchronizing.html"><strong aria-hidden="true">7.2.2.</strong> Synchronous</a></li><li class="chapter-item expanded "><a href="ch07-05-asynchronous.html"><strong aria-hidden="true">7.2.3.</strong> Asynchronous</a></li><li class="chapter-item expanded "><a href="ch07-06-deferred.html"><strong aria-hidden="true">7.2.4.</strong> Deferred Response</a></li><li class="chapter-item expanded "><a href="ch07-07-forwarding.html"><strong aria-hidden="true">7.2.5.</strong> Forwarding</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-graphics.html"><strong aria-hidden="true">8.</strong> Graphics Toolkit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-modals.html"><strong aria-hidden="true">8.1.</strong> Modals</a></li><li class="chapter-item expanded "><a href="ch08-02-menus.html"><strong aria-hidden="true">8.2.</strong> Menus</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Xous Operating System</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/betrusted-io/xous-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-xous-operating-system" id="the-xous-operating-system">The Xous Operating System</a></h1>
<p><em>by Sean &quot;xobs&quot; Cross and Andrew &quot;bunnie&quot; Huang, with contributions from the Rust Community</em></p>
<p>This version of the text assumes you’re using Rust 1.59.0 with the Xous library
installed.</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This book is a work in progress. Many chapters are placeholders and will appear blank.</p>
<p>The book is written for two audiences: kernel maintainers, and application developers.</p>
<p>Chapters <a href="ch02-00-server-architecture.html">2 (Server Architecture)</a>, <a href="ch03-00-introducing-the-kernel.html">3 (Introducing the Kernel)</a>, and <a href="ch05-00-system-startup.html">5 (System Startup)</a> are primarily for kernel maintainers and system programmers.</p>
<p>Chapters <a href="ch01-00-getting-started.html">1 (Getting Started)</a>, <a href="ch04-00-renode-emulation.html">4 (Renode Emulation)</a>, <a href="ch06-00-build-system-overview.html">6 (Build System Overview)</a>, <a href="ch07-00-messages.html">7 (Messages)</a> and <a href="ch08-00-graphics.html">8 (Graphics)</a> are more appropriate for application developers.</p>
<hr />
<h2><a class="header" href="#architecture" id="architecture">Architecture</a></h2>
<p><strong>Xous</strong> is a collection of small, single purpose <strong>Servers</strong> which respond to <strong>Messages</strong>. The Xous <strong>Kernel</strong> delivers Messages to Servers, allocates processing time to Servers, and transfers memory ownership from one Server to another. Every Xous Server contains a central loop that receives a Message, matches the Message <strong>Opcode</strong>, and runs the corresponding rust code. When the operation is completed, the Server waits to receive the next Message at the top of the loop, and processing capacity is released to other Servers. Every service available in Xous is implemented as a Server. Every user application in Xous is implemented as a Server.</p>
<p>Architecturally, Xous is most similar to <a href="https://www.qnx.com/developers/docs/6.4.1/neutrino/getting_started/s1_msg.html">QNX</a>, another microkernel message-passing OS.</p>
<h3><a class="header" href="#servers" id="servers">Servers</a></h3>
<p>There are only a few &quot;well known&quot; Servers which are always available to receive Messages, and run the requested Opcode:</p>
<ul>
<li>The <code>xous-name-server</code> maintains a list of all registered Servers by name, and guards a randomised 128-bit <strong>Server ID</strong> for each of the Servers. The xous-name-server arbitrates the flow of Messages between Servers.</li>
<li>The <code>ticktimer-server</code> provides time and time-out related services.</li>
<li>The <code>xous-log-server </code> provides logging services.</li>
<li>The <code>timeserverpublic</code> provides real-time (wall-clock time) services. It is only accessed via <code>std::time</code> bindings.</li>
</ul>
<p>The remaining servers are not &quot;well known&quot; - meaning that the <code>xous-name-server</code> must be consulted to obtain a Connection ID in order to send the Server a Message. Such Servers include <code>aes</code> <code>com</code> <code>dns</code> <code>gam</code> <code>jtag</code> <code>keyboard</code> <code>llio</code> <code>modals</code> <code>net</code> <code>pddb</code> <code>trng</code>.</p>
<h3><a class="header" href="#messages-aka-ipc" id="messages-aka-ipc">Messages, aka IPC</a></h3>
<p>Every <strong>Message</strong> contains a <strong>Connection ID</strong> and an <strong>Opcode</strong>. The Connection ID is a &quot;delivery address&quot; for the recipient Server, and the Opcode specifies a particular operation provided by the recipient Server. There are two flavours of messages in Xous:</p>
<ul>
<li><strong>Scalar messages</strong> are very simple and very fast. Scalar messages can transmit only 4 u32 sized arguments.</li>
<li><strong>Memory messages</strong> can contain larger structures, but they are slower. They &quot;transmit&quot; page-sized (4096-byte) memory chunks.</li>
</ul>
<p>Rust <code>struct</code>s need to be serialized into bytes before they can be passed using Memory Messages. Xous provides convenience bindings for <code>rkyv</code>, so any <code>struct</code> fully-annotated with <code>#[derive(rkyv::Archive, rkyv::Serialize, rkyv::Deserialize)]</code> can be serialized into a buffer by the sender and deserialized by the recipient.</p>
<p>The most simple Server communication involves a <strong>non-synchronizing</strong> &quot;fire and forget&quot; style of Messaging. The Sender sends a Message and continues processing immediately. The Recipient will receive the Message when it arrives, and process the Opcode accordingly. End of story. The ownership of the Message memory passes from the Sender to the Recipient and is Dropped by the Recipient. While there will be a delay before the Message is received - the sequence is assured. In the code, these are referred to as either <code>Scalar</code> Scalar Messages or <code>Send</code> Memory Messages.</p>
<p>Alternatively, A Server can send a <strong>synchronous</strong> Message, and wait (block) until the Recipient completes the operation and responds. In this arrangement, the Message memory is merely lent to the Recipient (read-only or read-write) and returned to the Sender on completion. While the sender Server &quot;blocks&quot;, its processing quanta is not wasted, but also &quot;lent&quot; to the Recipient Server to complete the request promptly. In the code, these are referred to as either <code>BlockingScalar</code> Scalar Messages, or <code>Borrow</code> or <code>MutableBorrow</code> Memory Messages. <code>Borrow</code> messages are read-only, <code>MutableBorrow</code> are read-write, with semantics enforced by the Rust borrow checker.</p>
<p><strong>asynchronous</strong> Message flow is also possible. The Sender will send a non-synchronous Message and include its own Connection ID as a &quot;return address&quot;. The Recipient Server will complete the operation, and then send a non-synchronous Message in reply to the Connection ID of the sender.</p>
<p>A Server may also send a synchronous Message and wait for a <strong>deferred-response</strong>. This setup is needed when the recipient Server cannot formulate a reply within a single pass of the event loop. Rather, the recipient Server must &quot;park&quot; the request and continue to process subsequent Messages until the original request can be satisfied. The request is &quot;parked&quot; by either saving the <code>msg.sender</code> field (for Scalar messages) or keeping a reference to the <code>MessageEnvelope</code> (for Memory messages). Memory Messages automatically return-on-Drop, relying on the Rust borrow checker and reference counting system to enforce implicit return semantics.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>The <a href="https://github.com/betrusted-io/betrusted-wiki/wiki">wiki</a> is going to be the most up-to-date source of information for getting started, as it is still a topic in flux.</p>
<p>Below are some excerpts from the Wiki, but some links may be out of date.</p>
<h2><a class="header" href="#update-your-device" id="update-your-device">Update Your Device</a></h2>
<ul>
<li><a href="https://github.com/betrusted-io/betrusted-wiki/wiki/Updating-Your-Device">Updating</a> your device.</li>
<li>Videos: <a href="https://vimeo.com/676414220/a590a017c3">Install a debug cable</a>; <a href="https://vimeo.com/676415520/51f9df8439">Assemble a Limited Edition</a></li>
<li><a href="https://ci.betrusted.io/latest-ci/">Bleeding-edge binaries</a> can be found at the CI server. Use at your own risk.</li>
<li><a href="https://ci.betrusted.io/releases/">Releases</a>: please check the corresponding README within each subdir for notes.</li>
</ul>
<h2><a class="header" href="#setting-up-security" id="setting-up-security">Setting up Security</a></h2>
<ul>
<li><a href="https://github.com/betrusted-io/betrusted-wiki/wiki/Inspecting-Your-Mainboard#trusted-domain-point-by-point">Inspecting your mainboard</a></li>
<li><a href="https://github.com/betrusted-io/betrusted-wiki/wiki/Initializing-Root-Keys">Initialize Root Keys</a> on &quot;factory new&quot; devices, by selecting the item from the main menu.</li>
<li>(Optional) <a href="https://github.com/betrusted-io/betrusted-wiki/wiki/FAQ:-FPGA-AES-Encryption-Key-(eFuse-BBRAM)#how-do-i-externally-provision-my-device">Burn Battery-Backed RAM keys</a> Note: do not use this if you plan to store long-term secrets on the device.</li>
</ul>
<h2><a class="header" href="#jargon" id="jargon">Jargon</a></h2>
<ul>
<li><a href="https://github.com/betrusted-io/betrusted-wiki/wiki/Jargon">Jargon</a>: Confused by terms like SoC and EC? You're not alone.</li>
</ul>
<h2><a class="header" href="#other-issues" id="other-issues">Other Issues</a></h2>
<h3><a class="header" href="#pre-boot--security" id="pre-boot--security">Pre-Boot &amp; Security</a></h3>
<ul>
<li><a href="https://github.com/betrusted-io/betrusted-wiki/wiki/How-Does-Precursor-Get-to-the-Reset-Vector%3F">What happens before boot?</a> fills in the details of everything that happens before the first instruction gets run.</li>
<li>&quot;<a href="https://github.com/betrusted-io/betrusted-wiki/wiki/Secure-Boot-and-KEYROM-Layout">Secure Boot</a>&quot; and key ROM layout</li>
<li><a href="https://github.com/betrusted-io/betrusted-wiki/wiki/FAQ:-FPGA-AES-Encryption-Key-(eFuse-BBRAM)">eFuse/BBRAM FPGA key</a> FAQ</li>
</ul>
<h3><a class="header" href="#between-the-software-and-hardware-hardware-abstractions" id="between-the-software-and-hardware-hardware-abstractions">Between the Software and Hardware: Hardware Abstractions</a></h3>
<ul>
<li><a href="https://github.com/betrusted-io/xous-core/tree/main/svd2utra">UTRA</a> Hardware register access abstraction for Xous</li>
<li><a href="https://github.com/betrusted-io/xous-core/wiki/Peripheral-Access-Conventions">Peripheral access conventions</a> Goals for hardware register abstractions</li>
<li><a href="https://github.com/betrusted-io/betrusted-wiki/wiki/Embedded-Controller-(EC)-COM-Protocol">COM</a> Protocol between the embedded controller (EC) and the main SoC</li>
</ul>
<h3><a class="header" href="#hardware-documentation" id="hardware-documentation">Hardware Documentation</a></h3>
<ul>
<li><a href="https://ci.betrusted.io/betrusted-soc/doc/index.html">SoC register set</a> / generated from <a href="https://github.com/betrusted-io/betrusted-soc/blob/main/betrusted_soc.py">SoC Litex Design Source</a></li>
<li><a href="https://github.com/betrusted-io/betrusted-soc#readme">SoC block diagram</a> is embedded in the README for the SoC</li>
<li><a href="https://ci.betrusted.io/betrusted-ec/doc/">EC register set</a> / generated from <a href="https://github.com/betrusted-io/betrusted-ec/blob/main/betrusted_ec.py">EC Litex Design Source</a></li>
<li><a href="https://github.com/betrusted-io/betrusted-hardware">Hardware design files</a> PDFs of schematics are in the &quot;mainboard-*&quot; directories</li>
</ul>
<h3><a class="header" href="#trng-chronicles" id="trng-chronicles">TRNG Chronicles</a></h3>
<ul>
<li><a href="https://betrusted.io/avalanche-noise">Physics and electrical design</a> of the external Avalanche generator</li>
<li>Notes on <a href="https://github.com/betrusted-io/betrusted-wiki/wiki/TRNG-characterization">Characterization</a> and debugging of raw sources</li>
<li><a href="https://github.com/betrusted-io/betrusted-wiki/wiki/TRNG-Online-Health-Monitors">On-line health monitoring</a></li>
<li><a href="https://github.com/betrusted-io/betrusted-wiki/wiki/TRNG-Data-Conditioning">Post-Generation Conditioning</a> with ChaCha</li>
</ul>
<h3><a class="header" href="#audit-trail" id="audit-trail">Audit Trail</a></h3>
<ul>
<li><a href="https://github.com/betrusted-io/crate-scraper">crate-scraper</a> is the beginning of a tool that helps with audit trails. It saves all the source code derived from <code>crates.io</code> to build Xous, and collates all the <code>build.rs</code> files into a <a href="https://github.com/betrusted-io/crate-scraper/blob/main/builds.rs">single mega-file</a> for faster manual inspection.</li>
</ul>
<h3><a class="header" href="#meta-issues" id="meta-issues">Meta-Issues</a></h3>
<ul>
<li><a href="https://github.com/betrusted-io/xous-core/tree/main/imports">imports</a> How imported repositories that are not yet stand-alone crates are managed</li>
<li><a href="https://github.com/betrusted-io/xous-core/tree/main/emulation">Emulation</a></li>
<li><a href="https://github.com/betrusted-io/xous-core/tree/main/tools">Tools</a> Helper tools to build bootable images</li>
<li><a href="https://github.com/betrusted-io/betrusted-wiki/wiki/Going-from-ODT-to-Github-Wiki">Converting Wiki Pages</a> from ODT to Markdown</li>
</ul>
<h1><a class="header" href="#hello-world" id="hello-world">Hello, World!</a></h1>
<ul>
<li>You will need the latest stable Rust. For now, Xous is tightly coupled to the latest stable Rust toolchain.</li>
<li>One should be able to run <code>cargo xtask run</code> after cloning <a href="https://github.com/betrusted-io/xous-core">xous-core</a>, and it will pop up a &quot;host-mode&quot; emulated version of Precursor.
<ul>
<li>You should be prompted to install the <code>xous</code> target; if this fails, you can follow <a href="https://github.com/betrusted-io/rust#readme">these instructions</a>. You may need to remove the target directory, as well, to reset the build state after installing.</li>
<li>You may also need to install some additional libraries, such as <code>libxkbdcommon-dev</code>.</li>
<li>:warning: hosted mode is literally Xous running on your local host, which means it supports more features than Xous on native hardware:
<ul>
<li>We do not have <code>tokio</code> support planned anytime soon.</li>
<li>We do not have <code>File</code> support in Xous; instead, we have the <code>pddb</code>.</li>
<li><code>Net</code> support in actively in development and we hope to have fairly robust support for <code>libstd</code> <code>Net</code> but, note that <code>socket2</code> crate (which is not part of Rust <code>libstd</code>) does <em>not</em> recognize Xous as a supported host.</li>
</ul>
</li>
<li>It is recommended to try compiling your configuration for a real hardware target or Renode early on to confirm compatibility, before doing extensive development in hosted mode.</li>
</ul>
</li>
<li>Make your own app:
<ul>
<li>Please refer to the <a href="https://github.com/betrusted-io/xous-core/blob/main/apps/README.md">manifest.json</a> documentation for integration notes</li>
<li><a href="https://github.com/betrusted-io/xous-core/blob/main/apps/repl/README.md"><code>repl</code> app demo</a> is the starting point for users who want to interact with their device by typing commands. This demo leverages more of the Xous UX built-in frameworks.</li>
<li><a href="https://github.com/betrusted-io/xous-core/blob/main/apps/ball/README.md"><code>ball</code> app demo</a> is the starting point for users who prefer to run close to the bare iron, getting only key events and a framebuffer for crafting games and bespoke apps.</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#hello-renode" id="hello-renode">Hello, Renode!</a></h1>
<p>(work in progress)</p>
<h1><a class="header" href="#server-architecture" id="server-architecture">Server Architecture</a></h1>
<p>WIP documentation on kernel-side server architecture details. This chapter is for kernel implementers, and not application programmers.</p>
<p>See <a href="ch07-02-caller-idioms.html">caller idioms</a> and <a href="ch07-00-messages.html">messages</a> for details on how to use servers in application programs.</p>
<h1><a class="header" href="#synchronization-primitives" id="synchronization-primitives">Synchronization Primitives</a></h1>
<p>Synchronization primitives are provided via the Ticktimer Server. This includes mutexes, process sleeping, and condvars.</p>
<h2><a class="header" href="#thread-sleeping" id="thread-sleeping">Thread Sleeping</a></h2>
<p>Thread sleeping is a primitive that is implemented by the ticktimer
server.</p>
<p>This takes advantage of the fact that a sender will suspend a thread
until a <code>BlockingScalar</code> message is responded to.</p>
<p>In order to suspend a thread, simply send a <code>BlockingScalar</code> message
to the ticktimer server with an <code>id</code> of <code>1</code> and an <code>arg1</code> indicating
the number of milliseconds to sleep.</p>
<p>If you need  to sleep for more than 49 days, simply send multiple messages.</p>
<h2><a class="header" href="#mutex" id="mutex">Mutex</a></h2>
<p>Mutexes allow for multiple threads to safely access the same data.
Xous Mutexes have two paths: A fast path, and a slow path. Non-contended
Mutexes traverse the fast path and will not need a context switch.
Contended Mutexes will automatically fall back to the slow path.</p>
<p>The core of a Mutex is a single <code>AtomicUsize</code>. This value is 0 when
the Mutex is unlocked, and nonzero when it is locked.</p>
<h3><a class="header" href="#mutex-locking" id="mutex-locking">Mutex: Locking</a></h3>
<p>Locking a Mutex involves a simple <code>try_lock()</code> operation. In this
operation, atomic instructions are used to replace the value <code>0</code>
with the value <code>1</code>, failing if this is the case.</p>
<pre><code class="language-rust noplayground ignore">pub unsafe fn try_lock(&amp;self) -&gt; bool {
    self.locked.compare_exchange(0, 1, SeqCst, SeqCst).is_ok()
}
</code></pre>
<p>If the Mutex is locked, then the current thread will call <code>yield_slice()</code>
which hands execution to another thread in the current process in the hope
that the other thread will release its mutex.</p>
<p>This currently occurs three times.</p>
<p>If the lock still cannot be locked, then it is &quot;poisoned&quot;. Instead of
swapping <code>0</code> for <code>1</code>, the thread does an atomic Add of <code>1</code> to the current
value. If the resulting value is <code>1</code> then the lock was successfully
obtained and execution may continue as normal.</p>
<p>However, if the value is not <code>1</code> then the process falls back to the Slow Path. This involves sending a <code>BlockingScalar</code> to the ticktimer
server with an <code>id</code> of <code>6</code> and <code>arg1</code> set to the address of the Mutex.</p>
<h3><a class="header" href="#mutex-unlocking" id="mutex-unlocking">Mutex: Unlocking</a></h3>
<p>Unlocking a Mutex on the Fast Path simply involves subtracting <code>1</code> from
the Mutex. If the previous value was <code>1</code> then there were no other
threads waiting on the Mutex.</p>
<p>Otherwise, send a <code>BlockingScalar</code> to the ticktimer server with
an <code>id</code> of <code>7</code> and <code>arg1</code> set to the address of the Mutex.</p>
<h2><a class="header" href="#condvar" id="condvar">Condvar</a></h2>
<p>Condvar is Rust's name for &quot;conditional variables&quot;. Broadly speaking,
they are instances where one thread takes an area of memory and says
&quot;Wake me up sometime in the future.&quot; A different thread can then say
&quot;Wake up one other thread that's waiting on this object.&quot; Or it
can say &quot;Wake up all other threads that are waiting on this object.&quot;</p>
<h3><a class="header" href="#condvar-waiting-for-a-condition" id="condvar-waiting-for-a-condition">Condvar: Waiting for a Condition</a></h3>
<p>To suspend a thread until a condition occurs, or until a timeout hits,
allocate an area of memory for the condvar. Then send a <code>BlockingScalar</code>
message to the ticktimer server with an <code>id</code> of <code>8</code>. Set <code>arg1</code> to the
address of the condvar.</p>
<p>In order to add a timeout, set <code>arg2</code> to the number of milliseconds to
wait for. Times longer than 49 days are not supported, so multiple
calls will be required. If no timeout is required, pass <code>0</code> for <code>arg2</code>.</p>
<h3><a class="header" href="#condvar-signaling-wakeups" id="condvar-signaling-wakeups">Condvar: Signaling Wakeups</a></h3>
<p>To wake up another thread, send a <code>BlockingScalar</code> message to the ticktimer
server with an <code>id</code> of <code>9</code>, and set <code>arg1</code> to the address of the condvar.
<code>arg2</code> should contain the number of blocked threads to wake up.
In order to wake only one thread, pass <code>1</code>.</p>
<h1><a class="header" href="#introducing-the-kernel" id="introducing-the-kernel">Introducing the Kernel</a></h1>
<p>Xous is a microkernel design that tries to keep as little as possible inside the main kernel. Instead, programs can start &quot;Servers&quot; that process can connect to in order to accomplish a task.</p>
<p>Processes are isolated, and therefore an MMU is strongly recommended. One process can have multiple threads, and processes cannot interact with one another except by passing Messages.</p>
<p>A Message is a piece of data that can be sent to a Server. Messages contain one <code>usize</code> ID field that may be used to identify an opcode, and may additionally contain some memory or some <code>usize</code> scalars.</p>
<p>Additionally, a Message may be either blocking, in which case it will wait for the Server to respond, or non-blocking, where they will return immediately.</p>
<p>&quot;Drivers&quot; are really just Servers. For example, to print a string to the console, send a <code>StandardOutput</code> (1) opcode to the server &quot;xous-log-server &quot; with a <code>&amp;[u8]</code> attached to some memory. The process will block until the server is finished printing.</p>
<p>The entire Xous operating system is built from these small servers, making it easy to work on one component at a time.</p>
<h2><a class="header" href="#memory-and-mapping" id="memory-and-mapping">Memory and mapping</a></h2>
<p>Memory is obtained by issuing a <code>MapMemory</code> syscall. This call can optionally provide a physical address to map. If no memory is specified, a random phyiscal page is provided. The process has no way of knowing the physical address of the page.</p>
<p>If the caller allocates memory from the primary region, it will be zeroed. If it allocates memory from an ancillary region such as a registor or a framebuffer, then that memory will not be initialized.</p>
<p>Processes can use this to allocate memory-mapped regions in order to create drivers.</p>
<h2><a class="header" href="#interrupts" id="interrupts">Interrupts</a></h2>
<p>Processes can allocate interrupts by calling the <code>ClaimInterrupt</code> call. If an interrupt has not been used, then that process will become the new owner of that interrupt. This syscall requires you to specify an address of a function to call, and you may optionally provide an argument to pass to the function handler.</p>
<p>There is no way to disable interrupts normally, except by handling an interrupt. That is, interrupts are disabled inside of your interrupt handler, and will be re-enabled after your interrupt handler returns.</p>
<p>There are a very limited set of functions that may be called during an interrupt handler. You may send nonblocking Messages and allocate memory, for example. However you may not Yield or send blocking Messages.</p>
<p>A common pattern for &quot;disabling interrupts&quot; is to come up with an interrupt that does nothing but trigger on-demand and handling the requisite code in that function. This is used by the suspend/resume server, for example, in order to ensure nothing else is running when the system is powering down.</p>
<h2><a class="header" href="#supported-platforms-risc-v-32-and-hosted" id="supported-platforms-risc-v-32-and-hosted">Supported Platforms: RISC-V 32 and Hosted</a></h2>
<p>Xous currently supports two platforms: RISC-V 32 and Hosted mode.</p>
<p>RISC-V 32 is the hardware that ships in Betrusted and Precursor, and is what is available in the Renode emulator.</p>
<p>An additional platform is <code>Hosted</code> mode, which targets your desktop machine. This can be used to debug builds using desktop-class debuggers such as <code>rr</code> or even just <code>gdb</code>. You can also use profilers in order to discover where code performance can be improved.</p>
<p><code>Hosted</code> mode is discussed in <a href="ch03-02-hosted-mode.html">more detail later</a></p>
<h1><a class="header" href="#memory-management-in-xous" id="memory-management-in-xous">Memory Management in Xous</a></h1>
<p>Memory is allocated with the <code>MapMemory</code> syscall. This call accepts four arguments:</p>
<ul>
<li>physical: <code>Option&lt;NonZeroUsize&gt;</code>: The physical address you would like to allocate. Specify <code>None</code> if you don't need a particular address.</li>
<li>virtual: <code>Option&lt;NonZeroUsize&gt;</code>: The virtual address you would like to allocate. Specify <code>None</code> if you don't need a particular virtual address.</li>
<li>size: <code>NonZeroUsize</code>: The size of the region to allocate. This must be page-aligned.</li>
<li>flags: <code>MemoryFlags</code>: A list of platform-specific flags to apply to this region.</li>
</ul>
<p>The memory will return a <code>MemoryRange</code> that encompasses the given region.</p>
<p>You can free memory with <code>UnmapMemory</code>, though be very careful not to free memory that is currently in use. <code>UnmapMemory</code> simply takes the <code>MemoryRange</code> returned by <code>MapMemory</code>.</p>
<h2><a class="header" href="#physical-addresses" id="physical-addresses">Physical Addresses</a></h2>
<p>A program rarely needs to access physical addresses, and in most operating systems it's not the kind of thing you can actually <em>do</em>. However, Xous is designed to be embedded, so it's entirely legal to request a physical address.</p>
<p>The trick is that you can only request physical addresses that actually exist. For example, you cannot request a physical address for a mirrored region of a peripheral because that is not a valid address.</p>
<p><strong>If you request a physical address from main RAM, the memory will be zeroed when you receive it</strong>. Peripherals and ares that are not in main RAM will not be zeroed. It is for this reason that system services are recommended to claim all peripherals before running user programs.</p>
<h2><a class="header" href="#virtual-addresses" id="virtual-addresses">Virtual Addresses</a></h2>
<p>All Xous programs run with virtual memory enabled. Attempting to perform an illegal operation will result in an exception. If you have an exception handler installed, illegal memory accesses will run this exception handler which may fix up the exception.</p>
<h3><a class="header" href="#demand-paging" id="demand-paging">Demand Paging</a></h3>
<p>When you allocate memory using <code>MapMemory(None, None, ..., ...)</code>, you will be handed memory from the <code>DEFAULT_BASE</code>. This memory will not be backed by a real page, and will only be allocated by the kernel once you access the page. This allows threads to allocate large stacks without running out of memory immediately.</p>
<p>Pages that are mapped-but-unallocated are visible in a process' page table view. As an example, consider the following excerpt from a page table view:</p>
<pre><code class="language-text">    38 60026000 -&gt; 400a3000 (flags: VALID | R | W | USER | A | D)
    41 60029000 -&gt; 40108000 (flags: VALID | R | W | A | D)
    42 6002a000 -&gt; 40109000 (flags: VALID | R | W | A | D)
    43 6002b000 -&gt; 00000000 (flags: R | W)
    44 6002c000 -&gt; 00000000 (flags: R | W)
</code></pre>
<p>Addresses 0x60026000 (#38), 0x60029000 (#41), and 0x6002a000 (#42) are all allocated. The rest of the pages are valid-but-unallocated.</p>
<p>Address 0x60026000 (#38) is mapped to the process and has a valid physical address. Reads and writes to this page are backed by physical address 0x400a3000.</p>
<p>Addresses 0x60029000 (#41) and 0x6002a000 (#42) are still owned by the kernel, likely because they were being cleared.</p>
<p>Addresses 0x6002b000 (#43) and 0x6003c000 (#44) are on-demand allocated. They have no physical backing, and attempting to access them will result in a kernel fault where they will be allocated. When the page is allocated, it will be given the flags <code>R | W</code> in addition to default kernel flags.</p>
<h3><a class="header" href="#the-heap" id="the-heap">The Heap</a></h3>
<p>When we talk about &quot;The Heap&quot; we mean data that is managed by functions such as <code>malloc</code>. Xous has a pair of syscalls that behave vaguely like the Unix <code>brk</code> command.</p>
<p><code>IncreaseHeap(usize, MemoryFlags)</code> will increase a program's heap by the given amount. This returns the new heap as a <code>MemoryRange</code>.</p>
<p>To decrease the heap by a given amount, call <code>DecreaseHeap(usize)</code>.</p>
<p>Note that you must adjust the heap in units of <code>PAGE_SIZE</code>.</p>
<p>You can avoid using these syscalls by manually allocating regions using <code>MapMemory</code>, however they are a convenient abstraction with their own memory range.</p>
<p><code>liballoc</code> as bundled by Xous uses these syscalls as a backing for memory.</p>
<h3><a class="header" href="#virtual-memory-regions" id="virtual-memory-regions">Virtual Memory Regions</a></h3>
<p>There are different memory regions in virtual address space:</p>
<table><thead><tr><th>Address</th><th>Name</th><th>Variable</th><th>Description</th></tr></thead><tbody>
<tr><td>0x00010000</td><td>text</td><td>-</td><td>Start of <code>.text</code> with the default riscv linker script (<code>riscv64-unknown-elf-ld -verbose</code>)</td></tr>
<tr><td>0x20000000</td><td>heap</td><td>DEFAULT_HEAP_BASE</td><td>Start of the heap section returned by <code>IncreaseHeap</code></td></tr>
<tr><td>0x40000000</td><td>message</td><td>DEFAULT_MESSAGE_BASE</td><td>Base address where <code>MemoryMessage</code> messages are mapped inside of a server</td></tr>
<tr><td>0x60000000</td><td>default</td><td>DEFAULT_BASE</td><td>Default region when calling `MapMemory(..., None, ..., ...) -- most threads have their stack here</td></tr>
<tr><td>0x7fffffff</td><td>stack</td><td>-</td><td>The default stack for the first thread - grows downwards</td></tr>
<tr><td>0xff000000</td><td>kernel</td><td>USER_AREA_END</td><td>The end of user area and the start of kernel area</td></tr>
<tr><td>0xff400000</td><td>pgtable</td><td>PAGE_TABLE_OFFSET</td><td>A process' page table is located at this offset, accessible only to the kernel</td></tr>
<tr><td>0xff800000</td><td>pgroot</td><td>PAGE_TABLE_ROOT_OFFSET</td><td>The root page table is located at this offset, accessible only to the kernel</td></tr>
</tbody></table>
<p>In addition, there are special addresses that indicate the end of a function. The kernel will set these as the return address for various situations, and they are documented here for completeness:</p>
<table><thead><tr><th>Address</th><th>Name</th><th>Variable</th><th>Description</th></tr></thead><tbody>
<tr><td>0xff802000</td><td>retisr</td><td>RETURN_FROM_ISR</td><td>Indicates the return from an interrupt service routine</td></tr>
<tr><td>0xff803000</td><td>exitthr</td><td>EXIT_THREAD</td><td>Indicates a thread should exit</td></tr>
<tr><td>0xff804000</td><td>retex</td><td>RETURN_FROM_EXCEPTION_HANDLER</td><td>Indicates the return from an exception handler</td></tr>
</tbody></table>
<h1><a class="header" href="#hosted-mode" id="hosted-mode">Hosted Mode</a></h1>
<p>Hosted mode may be built by running <code>cargo xtask run</code>. This causes Xous to be compiled using your native architecture rather than building for <code>riscv32imac-unknown-xous-elf</code>. Your native architecture is probably 64-bits, and has a lot more memory than Betrusted does. Xous also runs in userspace, which means a lot of things end up being very different in this mode.</p>
<p>The API is designed to abstract away these differences so that programs may run seamlessly on both Hosted and Native (RISC-V 32) mode.</p>
<h2><a class="header" href="#the-kernel-as-a-process" id="the-kernel-as-a-process">The Kernel as a Process</a></h2>
<p>When you build processes using <code>cargo xtask run</code>, the kernel is compiled as an ordinary, native program. This program can be run by simply running <code>./target/release/kernel</code>. If you run this by itself after running <code>cargo xtask run</code>, you'll see the following output:</p>
<pre><code class="language-sh">$ ./target/release/kernel
KERNEL: Xous server listening on 127.0.0.1:1238
KERNEL: Starting initial processes:
  PID  |  Command
-------+------------------
</code></pre>
<p>The kernel simply acts as a router, passing messages between processes. This poses some challenges because processes need to be able to connect to one another, and the kernel needs to be able to match a network connection to a given process. Additionally, there needs to be a list of initial processes to start.</p>
<h2><a class="header" href="#initial-processes" id="initial-processes">Initial Processes</a></h2>
<p>In order to get a list of initial processes, they are simply all passed on the command line. For example, we can run the kernel with a log server and see the following output:</p>
<pre><code class="language-sh">$ ./target/release/kernel ./target/release/log-server
KERNEL: Xous server listening on 127.0.0.1:21183
KERNEL: Starting initial processes:
  PID  |  Command
-------+------------------
   2   |  ./target/release/log-server
LOG: my PID is 2
LOG: Creating the reader thread
LOG: Running the output
LOG: Xous Logging Server starting up...
LOG: Server listening on address SID([1937076088, 1735355437, 1919251245, 544367990])
LOG: my PID is 2
LOG: Counter tick: 0
</code></pre>
<p>From this output, we can see that the kernel has started the log server for us. Multiple initial processes may be specified:</p>
<pre><code class="language-sh">$ ./target/release/kernel ./target/release/log-server ./target/release/xous-names
KERNEL: Xous server listening on 127.0.0.1:3561
KERNEL: Starting initial processes:
  PID  |  Command
-------+------------------
   2   |  ./target/release/log-server
   3   |  ./target/release/xous-names
LOG: my PID is 2
LOG: Creating the reader thread
LOG: Running the output
LOG: Xous Logging Server starting up...
LOG: Server listening on address SID([1937076088, 1735355437, 1919251245, 544367990])
LOG: my PID is 2
LOG: Counter tick: 0
INFO:xous_names: my PID is 3 (services/xous-names/src/main.rs:360)
INFO:xous_names: started (services/xous-names/src/main.rs:375)
</code></pre>
<h2><a class="header" href="#launching-a-process" id="launching-a-process">Launching a Process</a></h2>
<p>Processes are launched in the kernel by setting a series of environment variables and then spawning a new process. The following environment variables are currently used:</p>
<table><thead><tr><th>Variable</th><th>Description</th></tr></thead><tbody>
<tr><td>XOUS_SERVER</td><td>The IP and TCP port of the kernel</td></tr>
<tr><td>XOUS_PID</td><td>The unique process ID of this kernel, assigned by the Xous kernel</td></tr>
<tr><td>XOUS_PROCESS_NAME</td><td>The process name, currently taken from the executable name</td></tr>
<tr><td>XOUS_PROCESS_KEY</td><td>An 8-byte hex-encoded key that uniquely identifies this process</td></tr>
</tbody></table>
<p>A thread is created for this process to handle it and to route messages within the kernel. The <code>XOUS_PROCESS_KEY</code> is effectively a single-use token that is unique per process and is used to match a process within the kernel.</p>
<p>When the process launches it should establish a connection to the kernel by connecting to <code>XOUS_SERVER</code> and sending <code>XOUS_PROCESS_KEY</code>. This will authenticate the process with the kernel ane enable it to send and receive messages.</p>
<p>The initial handshake has the following layout:</p>
<table><thead><tr><th>Offset (Bytes)</th><th>Size</th><th>Meaning</th></tr></thead><tbody>
<tr><td>0</td><td>1</td><td>Process ID of connecting process</td></tr>
<tr><td>1</td><td>8</td><td>8-byte process key</td></tr>
</tbody></table>
<h2><a class="header" href="#sending-and-receiving-syscalls" id="sending-and-receiving-syscalls">Sending and Receiving Syscalls</a></h2>
<p>In Hosted mode, syscalls are sent via a network connection. Because pointers are unsafe to send, <code>usize</code> is defined on Hosted mode as being 32-bits. Additionally, most syscalls will return <code>NotImplemented</code>, for example it does not make sense to create syscalls such as <code>MapMemory</code>.</p>
<p>Messages function normally in Hosted mode, however they are more expensive than on real hardware. Because messages get sent via the network, the entire contents of a Memory message must be sent across the wire.</p>
<p>Eight 32-bit values are sent, and these may be followed by any data in case there is a Memory message.</p>
<table><thead><tr><th>Offset (Bytes)</th><th>Usage (Calling)</th></tr></thead><tbody>
<tr><td>0</td><td>Source thread ID</td></tr>
<tr><td>4</td><td>Syscall Number</td></tr>
<tr><td>8</td><td>Arg 1</td></tr>
<tr><td>12</td><td>Arg 2</td></tr>
<tr><td>16</td><td>Arg 3</td></tr>
<tr><td>20</td><td>Arg 4</td></tr>
<tr><td>24</td><td>Arg 5</td></tr>
<tr><td>28</td><td>Arg 6</td></tr>
<tr><td>32</td><td>Arg 7</td></tr>
<tr><td>36</td><td>Contents of any buffer pointed to by args</td></tr>
</tbody></table>
<p>The process should expect a return, and should block until it gets a response. When it gets a response, a memory buffer may be required that is the same size as the buffer that was sent. The contents of this buffer will be appended to the network packet in the same manner as the calling buffer. If the message is a Borrow, then this data will be the same as the data that was sent. If it is a MutableBorrow, then the server may manipulate this data before it returns.</p>
<table><thead><tr><th>Offset (Bytes)</th><th>Usage (Return)</th></tr></thead><tbody>
<tr><td>0</td><td>Target thread ID</td></tr>
<tr><td>4</td><td>Return type tag</td></tr>
<tr><td>8</td><td>Arg 1</td></tr>
<tr><td>12</td><td>Arg 2</td></tr>
<tr><td>16</td><td>Arg 3</td></tr>
<tr><td>20</td><td>Arg 4</td></tr>
<tr><td>24</td><td>Arg 5</td></tr>
<tr><td>28</td><td>Arg 6</td></tr>
<tr><td>32</td><td>Arg 7</td></tr>
<tr><td>36</td><td>Contents of any returned buffer</td></tr>
</tbody></table>
<h2><a class="header" href="#threading" id="threading">Threading</a></h2>
<p>All Xous syscalls go to the kernel, however certain syscalls are simply stubs. One example of this is threading, where the kernel has no way of actually launching a thread.</p>
<p>The application is responsible for creating new threads, and may do so either by &quot;sending&quot; a <code>CreateThread</code> call to the kernel or by creating a native thread using <code>std::Thread::spawn()</code>.</p>
<p>When launching a thread with <code>CreateThread</code>, the kernel will allocate a nwe &quot;Xous TID&quot; and return that to the application. The application will then launch its new thread and set the local <code>THREAD_ID</code> variable to this ID. This ID will be used as part of the header when sending syscalls to the kernel, and will be used to delegate responses to their waiting threads.</p>
<p>If an application calls <code>std::Thread::spawn()</code> then it will not have a <code>THREAD_ID</code> set. When the thread attempts to send a syscall, hosted mode will notice that <code>THREAD_ID</code> is None. When this occurs, Hosted mode will create a &quot;fake&quot; thread ID (starting at TID 65536) and call <code>SysCall::CreateThread(ThreadInit {})</code> to register this new ID. Then all subsequent calls will use this fake thread ID.</p>
<h1><a class="header" href="#process-creation" id="process-creation">Process Creation</a></h1>
<p>Creating processes is a fundamental requirement of modern operating systems above a certain size. Xous supports process creation, although it does not prescribe an executable format nor does it even have a built-in loader.</p>
<p>Process creation arguments vary depending on the platform being targeted, making this one of the less portable aspects of Xous. All platforms support the <code>CreateProcess</code> syscall, however the arguments to this syscall vary widely.</p>
<h2><a class="header" href="#creating-processes-in-hosted-mode" id="creating-processes-in-hosted-mode">Creating Processes in Hosted Mode</a></h2>
<p>In Hosted mode, the <code>ProcessArgs</code> struct contains a full command line to be passed directly to the shell. This is actually used by the kernel during its init routine when it spawns each child process of PID 1.</p>
<p>Internally, the parent process is responsible for launching the process as part of the <code>create_process_post()</code> that gets called after the successful return of the <code>CreateProcess</code> syscall. As part of this, the hook sets various environment variables for the child process such as its 16-byte key stored in the <code>XOUS_PROCESS_KEY</code> variable, as well as the PID stored in the <code>XOUS_PID</code> variable.</p>
<h2><a class="header" href="#creating-processes-in-test-mode" id="creating-processes-in-test-mode">Creating Processes in Test Mode</a></h2>
<p>Test mode is a special case. Tests don't want to depend on files in the filesystem, particularly as multiple tests are running at the same time. To work around this, processes are created as threads. This is a special case intended to support heavily-parallel machines that can run all thread tests simultaneously, and is not normally used.</p>
<h2><a class="header" href="#creating-processes-on-native-hardware-eg-risc-v" id="creating-processes-on-native-hardware-eg-risc-v">Creating Processes on Native Hardware (e.g. RISC-V)</a></h2>
<p>Process creation on real hardware requires a minimum of six pieces of information. These are all defined in the <code>ProcessInit</code> struct, which gets passed directly to the kernel:</p>
<pre><code class="language-rust noplayground ignore">pub struct ProcessInit {
    // 0,1 -- Stack Base, Stack Size
    pub stack: crate::MemoryRange,
    // 2,3 -- Text Start, Text Size
    pub text: crate::MemoryRange,
    // 4 -- Text destination address
    pub text_destination: crate::MemoryAddress,
    // 5 -- Entrypoint (must be within .text)
    pub start: crate::MemoryAddress,
}
</code></pre>
<p>The <code>stack</code> defaults to 128 kB growing downwards from <code>0x8000_0000</code>.</p>
<p><code>text</code> refers to a region of memory <strong>INSIDE YOUR PROGRAM</strong> that will be detached and moved to the child process. This memory will form the initialization routine for the child process, and should contain no <code>.bss</code> or <code>.data</code> sections, unless it also contains code to allocate and set up those sections.</p>
<p><code>text_destination</code> describes the offset where <code>text</code> will be copied. This address is determined by the link address of your initialization program. </p>
<p>The <code>start</code> is the address where the program counter will start. This is the address of your program's entrypoint. It must reside within the allocated text section, beginning at <code>text_destination</code>.</p>
<h3><a class="header" href="#native-hardware-entrypoint" id="native-hardware-entrypoint">Native Hardware Entrypoint</a></h3>
<p>The entrypoint for native hardware takes four arguments. When combined, these four arguments form a Server ID that can be used for sending additional data from the parent process to the child. An example loader program might look like the following:</p>
<pre><code class="language-rust noplayground ignore">pub extern &quot;C&quot; fn init(a1: u32, a2: u32, a3: u32, a4: u32) -&gt; ! {
    let server = xous::SID::from_u32(a1, a2, a3, a4);
    while let Ok(xous::Result::Message(envelope)) =
        xous::rsyscall(xous::SysCall::ReceiveMessage(server))
    {
        match envelope.id().into() {
            StartupCommand::WriteMemory =&gt; write_memory(envelope.body.memory_message()),
            StartupCommand::FinishStartup =&gt; finish_startup(server, envelope),
            StartupCommand::PingResponse =&gt; ping_response(envelope),

            _ =&gt; panic!(&quot;unsupported opcode&quot;),
        }
    }
    panic!(&quot;parent exited&quot;);
}
</code></pre>
<p>This compiles down to a very efficient program that can be used to load a larger program into the new address space. Memory is written using the <code>WriteMemory</code> opcode to load new pages into the nacent process, and <code>FinishStartup</code> is used to shut down the server and jump to the new process entrypoint.</p>
<h3><a class="header" href="#limitations-of-created-processes" id="limitations-of-created-processes">Limitations of Created Processes</a></h3>
<p><strong>NOTE:</strong> The following is subject to fixes in the kernel, and do not currently apply. This information is presented here in order to explain oddities observed when these features are implemented.</p>
<p>Newly-created processes cannot create servers with a predefined Server ID. They can only create randomized servers.</p>
<p>Processes created using <code>CreateProcess</code> are not ever scheduled to run. Parent processes must donate their quantum to child processes in order for them to run. This is done with a special syscall.</p>
<p>When a parent process exits, all child processes will also exit. This is because those processes will not be scheduled anymore, so there's no point in letting them continue to run.</p>
<h1><a class="header" href="#renode-emulation" id="renode-emulation">Renode Emulation</a></h1>
<p><a href="https://renode.io/">Renode</a> is a multi-device emulator written in C#. It is designed to assist in testing and development of software, and is also useful in developing new hardware blocks.</p>
<p>The emulator is available for Windows, Mac, and Linux. It is designed to simulate whole systems of devices, meaning it can easily capture the interactions between devices on a network or bus. It allows you to pause the system and inspect memory, single-step, and watch various sections of the bus.</p>
<p>There is extensive end-user documentation available at <a href="https://renode.readthedocs.io/en/latest/">Read the Docs</a>, which is highly recommended. The remainder of this chapter will cover recommendations on how to use Renode with Xous.</p>
<h1><a class="header" href="#writing-renode-c-peripherals" id="writing-renode-c-peripherals">Writing Renode C# Peripherals</a></h1>
<p>Renode is written in C#, which means it has access to the entire base of C#. One feature of C# is the <code>CSharpCodeProvider</code> object which provides the <code>CompileAssemblyFromSource(CompilerParameters, string[])</code> function. This means that Renode has a runtime C# compiler built in.</p>
<p>You can <code>include</code> C# files in the Renode console or in your startup script to dynamically add new peripherals to your environment. Xous uses this extensively in Betrusted since the hardware peripherals are still under development and therefore change regularly. Updating a hardware module in Renode simply involves modifying the <code>.cs</code> file and restarting Renode. There is no additional compile step.</p>
<h2><a class="header" href="#setting-up-an-ide----visual-studio-code" id="setting-up-an-ide----visual-studio-code">Setting up an IDE -- Visual Studio Code</a></h2>
<p>It is highly recommended to use a full IDE. The Renode API can change, and it can take time to restart Renode to recompile your C# files. An IDE will provide you with tab-completion and will immediately tell you if there is a code error.</p>
<p>The core of Renode is written in a full IDE such as Visual Studio or Monodevelop. These IDEs expect a full Project file that defines a single target output -- for example an executable or a linked library. With our usage of C# there is no single target since Renode will dynamically load the source files. To work around this, we create a stub project file that tricks the IDE into loading our assembly files and providing autocomplete. We never actually <em>use</em> this project file, but it's used behind the scenes automatically.</p>
<p>Broadly speaking, there are three steps to setting up an IDE:</p>
<ol>
<li>Download Visual Studio Code</li>
<li>Copy the reference project file</li>
<li>Modify the reference project file</li>
<li>Install the C# extension.</li>
</ol>
<p>To begin with download <a href="https://code.visualstudio.com/">Visual Studio Code</a>. It is available for Windows, Linux, and Mac.</p>
<p>Next, copy <code>emulation/peripherals.csproj.template</code> to <code>emulation/peripherals.csproj</code>. This is a C# Project file that is understood by Visual Studio and Visual Studio Code. The file name <code>peripherals.csproj</code> is in the <code>.gitignore</code> file, so don't worry about accidentally checking it in.</p>
<p>Edit <code>peripherals.csproj</code> and modify <code>RenodePath</code> to point to your Renode installation where the <code>.dll</code> files are located. On Linux this is likely <code>/opt/renode/bin</code>. On Windows this may be in <code>C:\Program Files\</code>.</p>
<p>Finally, install the <a href="https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp">C# for Visual Studio Code</a> extension. This extension will activate, parse your <code>.csproj</code>, and start providing autocomplete and compile suggestions.</p>
<h2><a class="header" href="#creating-a-new-peripheral" id="creating-a-new-peripheral">Creating a new Peripheral</a></h2>
<p>To create a new peripheral, simply copy an existing peripheral to a new filename under <code>emulation/peripherals/</code>, making sure the filename ends in <code>.cs</code>.</p>
<p>Many examples exist in the <code>emulation/peripherals/</code> directory, and you can find many more examples <a href="https://github.com/renode/renode-infrastructure/tree/master/src/Emulator/Peripherals/Peripherals">built into Renode</a>.</p>
<p>A simple example could be a device that provides random numbers:</p>
<pre><code class="language-cs">using Antmicro.Renode.Core;
using Antmicro.Renode.Core.Structure.Registers;
using Antmicro.Renode.Logging;

namespace Antmicro.Renode.Peripherals.Miscellaneous
{
    public class ExampleRNGServer : BasicDoubleWordPeripheral, IKnownSize
    {
        public long Size { get { return 0x100; } }
        public GPIO IRQ { get; private set; }
        private readonly PseudorandomNumberGenerator rng = EmulationManager.Instance.CurrentEmulation.RandomGenerator;
        private bool enabled = true;

        private enum Registers
        {
            CONTROL = 0x0,
            DATA = 0x4,
            STATUS = 0x8,
            AV_CONFIG = 0xc,
            RO_CONFIG = 0x10,

            READY = 0xc4,
            EV_STATUS = 0xc8,
            EV_PENDING = 0xcc,
            EV_ENABLE = 0xd0,
            URANDOM = 0xdc,
            URANDOM_VALID = 0xe0,
            TEST = 0xf8,
        }

        public ExampleRNGServer(Machine machine) : base(machine)
        {
            this.IRQ = new GPIO();
            DefineRegisters();
        }


        private void DefineRegisters()
        {

            Registers.URANDOM.Define(this)
                .WithValueField(0, 32, FieldMode.Read, valueProviderCallback: _ =&gt;
                {
                    if (!enabled)
                        return 0;
                    return (uint)rng.Next();
                }, name: &quot;URANDOM&quot;);
            Registers.DATA.Define(this)
                .WithValueField(0, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
                {
                    if (!enabled)
                        return 0;
                    return (uint)rng.Next();
                }, name: &quot;DATA&quot;)
                .WithValueField(16, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
                {
                    return 0xf00f;
                }, name: &quot;SIGNATURE&quot;);
            Registers.URANDOM_VALID.Define(this)
                .WithFlag(0, FieldMode.Read, valueProviderCallback: _ =&gt; { return true; }, name: &quot;URANDOM_VALID&quot;)
                .WithFlag(1, FieldMode.Read, valueProviderCallback: _ =&gt; { return enabled; }, name: &quot;ENABLE&quot;);

            Registers.CONTROL.Define(this)
                .WithFlag(0, FieldMode.Write, writeCallback: (_, val) =&gt; { enabled = val; }, name: &quot;ENABLE&quot;);
        }
    }
}
</code></pre>
<p>There's a lot to take in there, particularly if you've never dealt with C# before. Let's go over the module line-by-line.</p>
<pre><code class="language-cs">using Antmicro.Renode.Core;
using Antmicro.Renode.Core.Structure.Registers;
using Antmicro.Renode.Logging;
</code></pre>
<p>The first three lines import various packages to the current namespace. You'll most likely use these in all of your projects. Any valid C# namespace may be used, including core <code>.Net</code> libraries. This can be useful if you need networking, cryptography, or other exotic libraries. There are many useful logging functions as well. You'll notice that the final line is darker than the other two. This is because this package is currently unused -- we don't perform any logging currently. You can safely remove this final line, however it's useful to leave Logging as an import because it allows for autocompletion of Logging functions.</p>
<pre><code class="language-cs">namespace Antmicro.Renode.Peripherals.Miscellaneous {
</code></pre>
<p>Next, we define the namespace for this module. The module MUST be under a <code>namespace Antmicro.Renode.Peripherals.xxx</code> namespace. In this case, it is under <code>Antmicro.Renode.Peripherals.Miscellaneous</code>. This namespacing provides a handy structure to various peripherals.</p>
<pre><code class="language-cs">public class ExampleRNGServer : BasicDoubleWordPeripheral, IKnownSize {
</code></pre>
<p>Finally, we begin to define our class. This class is named <code>ExampleRNGServer</code>, and it inherits <code>BasicDoubleWordPeripheral</code> and <code>IKnownSize</code>.</p>
<p>The <code>BasicDoubleWordPeripheral</code> class provides several convenience functions that makes it easy to create a memory-mapped device. It means we don't need to manage accessors, and we can simply worry about the register values themselves.</p>
<p>Peripherals need to have a known size, so we inform C# that our client has a known size. The <code>I</code> stands for Interface. To find out which functions we must implement to conform to <code>IKnownSize</code>, hold Ctrl and click on <code>IKnownSize</code>. It will take you to the definition of <code>IKnownSize</code>, located inside <code>Emulator.dll</code>. You will note that the only thing we need to implement is <code>log Size { get; }</code>, which means we only need to create an accessor for the property <code>Size</code>.</p>
<pre><code class="language-cs">public long Size { get { return 0x100; } }
public GPIO IRQ { get; private set; }
private readonly PseudorandomNumberGenerator rng = EmulationManager.Instance.CurrentEmulation.RandomGenerator;
private bool enabled = true;
</code></pre>
<p>Here we define our local properties and variables. We can see the <code>Size</code> property defined here. Our peripheral goes up to <code>0xf8</code>, so we return that as a constant. This is used by Renode to ensure peripherals don't overlap, and to know which peripheral to invoke when memory is accessed.</p>
<p>There is an IRQ here as well, which is a <code>GPIO</code>. The way Renode handles interrupts is by reusing GPIO pins. We can trigger an interrupt by setting this GPIO, and the system will invoke an interrupt context on the CPU.</p>
<p>Finally there is a local variable that is part of this object and not visible outside of our class.</p>
<pre><code class="language-cs">private enum Registers
{
    CONTROL = 0x0,
    DATA = 0x4,
    STATUS = 0x8,
    AV_CONFIG = 0xc,
    RO_CONFIG = 0x10,

    READY = 0xc4,
    EV_STATUS = 0xc8,
    EV_PENDING = 0xcc,
    EV_ENABLE = 0xd0,
    URANDOM = 0xdc,
    URANDOM_VALID = 0xe0,
    TEST = 0xf8,
}
</code></pre>
<p>We define an enum called <code>Registers</code>. This is simply a mapping of register names to register numbers. It is not a particularly special enum, however correct naming of the enum values will make it easier to define the register set later on. It is standard practice to define all possible registers in this enum, even if you do not implement them right away.</p>
<pre><code class="language-cs">public ExampleRNGServer(Machine machine) : base(machine)
{
    this.IRQ = new GPIO();
    DefineRegisters();
}
</code></pre>
<p>This is the constructor for our device. It takes a single argument of type <code>Machine</code>. Because we inherit from <code>BasicDoubleWordPeripheral</code>, we will need to call the constructor for the base class. To figure out what the constructor looks like, hold Ctrl and click on <code>BasicDoubleWordPeripheral</code>. We can see that the constructor for that class simply takes one argument that's a <code>Machine</code>. Therefore, the first line of our constructor should invoke the base constructor directly. Which is what we do here.</p>
<p>We create a new GPIO and assign it to the IRQ. Renode will access our <code>IRQ</code> property if it wants to watch for interrupts. If our peripheral has no interrupts we can omit the <code>IRQ</code> property.</p>
<pre><code class="language-cs">private void DefineRegisters() {
</code></pre>
<p>Finally, we invoke the <code>DefineRegisters()</code> function. It is the most complicated function in this class, however it's where most of the work is done. Let's look at each register definition in order.</p>
<pre><code class="language-cs">Registers.URANDOM.Define(this)
    .WithValueField(0, 32, FieldMode.Read, valueProviderCallback: _ =&gt;
    {
        if (!enabled)
            return 0;
        return (uint)rng.Next();
    }, name: &quot;URANDOM&quot;);
</code></pre>
<p>The <code>Define(this)</code> function comes from <code>BasicDoubleWordPeripheralExtensions</code>, which is one of the classes provided to us as a subclass of <code>BasicDoubleWordPeripheral</code>. It allows us to define a register on an enum type.</p>
<p>The <code>WithValueField()</code> function defines a value for a register across a range of values. In this case, we define a value beginning at bit 0 that is 32-bits wide. We define this register as a <code>FieldMode.Read</code> register, meaning writes will be ignored. When a device accesses this register, the <code>valueProviderCallback</code> function will be called.</p>
<p>What follows is a C# closure. The first argument is the register itself, which we ignore since we are not interested in it. Therefore, the variable is named <code>_</code>. If the block is disabled, we return 0, otherwise we return a <code>uint</code> from the class RNG provider.</p>
<p>Finally, we name the register <code>URANDOM</code>.</p>
<pre><code class="language-cs">Registers.DATA.Define(this)
    .WithValueField(0, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
    {
        if (!enabled)
            return 0;
        return (uint)rng.Next();
    }, name: &quot;DATA&quot;)
    .WithValueField(16, 16, FieldMode.Read, valueProviderCallback: _ =&gt;
    {
        return 0xf00f;
    }, name: &quot;SIGNATURE&quot;);
</code></pre>
<p>This register contains two value fields. The first is at offset 0, and is 16-bits wide. The second is at offset 16, and is also 16-bits wide.</p>
<p>The <code>valueProviderCallback</code> function is called for each field, which avoids the need for any manual bit shifting.</p>
<p>If the peripheral is not enabled, then the <code>DATA</code> field returns 0. If it is enabled, then it returns a 16-bit random value.</p>
<p>Because of the way this register is defined, the top 16 bits will always be <code>0xf00f</code>. Therefore, the register's value will be either <code>0xf00f0000</code> or <code>0xf00fRAND</code>.</p>
<pre><code class="language-cs">Registers.URANDOM_VALID.Define(this)
    .WithFlag(0, FieldMode.Read, valueProviderCallback: _ =&gt; { return true; }, name: &quot;URANDOM_VALID&quot;)
    .WithFlag(1, FieldMode.Read, valueProviderCallback: _ =&gt; { return enabled; }, name: &quot;ENABLE&quot;);
</code></pre>
<p>This register defines two flags. The first flag is at bit 0, and the second flag is at bit 1. Flags are always one-bit boolean values, which is why the <code>valueProviderCallback</code> returns <code>true</code> instead of a <code>uint</code> like we've seen in the past. Similarly to <code>WithValueField()</code>, a <code>WithFlag</code> value will call the <code>valueProviderCallback</code> for each flag, avoiding the need to do complex shifting.</p>
<pre><code class="language-cs">Registers.CONTROL.Define(this)
    .WithFlag(4, FieldMode.Write, writeCallback: (_, val) =&gt; { enabled = val; }, name: &quot;ENABLE&quot;);
</code></pre>
<p>Finally we define the <code>CONTROL</code> register. Our implementation simply has an <code>ENABLE</code> bit at offset 4. This is the first time we've seen a <code>writeCallback</code>. This closure takes two arguments: the register itself and the written value. </p>
<h2><a class="header" href="#using-the-new-peripheral" id="using-the-new-peripheral">Using the new peripheral</a></h2>
<p>To use the new peripheral, save it in a <code>.cs</code> file, then include it in Renode. For example, if it was called <code>examplerngserver.cs</code>, you would include it in Renode by running:</p>
<pre><code class="language-text">(renode) i @examplerngserver.cs
</code></pre>
<p>You can then use the <code>Miscellaneous.ExampleRNGServer</code> peripheral in any platform definition. For example, to create a new peripheral at offset <code>0x40048000</code> in the current machine, use the <code>LoadPlatformDescriptionFromString</code> command:</p>
<pre><code class="language-text">(renode) machine LoadPlatformDescriptionFromString 'rng: Miscellaneous.ExampleRNGServer @ sysbus 0x40048000'
</code></pre>
<p>Now, any accesses to <code>0x40048000</code> will be directed to your new peripheral.</p>
<h1><a class="header" href="#xous-operating-system-startup" id="xous-operating-system-startup">Xous Operating System Startup</a></h1>
<p>The Xous operating system is set up by the loader, which is responsible for unpacking data into RAM and setting up processes. It is covered in the <a href="ch05-02-loader.html">Xous Loader</a> section.</p>
<p>The loader reads a binary stream of data located in a tagged format that is discussed in the <a href="ch05-01-arguments.html">Arguments Structure</a> section. This arguments structure defines features such as the memory layout, system configuration, and initial process data.</p>
<p>Programs are loaded in flattened foramts called <code>MiniELF</code>, which is documented in the <a href="ch05-03-minielf.html">MiniELF Format</a> section.</p>
<p>You may also find the following links of interest:</p>
<ul>
<li><a href="https://github.com/betrusted-io/betrusted-wiki/wiki/How-Does-Precursor-Get-to-the-Reset-Vector%3F">What happens before boot?</a> fills in the details of everything that happens before the first instruction gets run.</li>
<li>&quot;<a href="https://github.com/betrusted-io/betrusted-wiki/wiki/Secure-Boot-and-KEYROM-Layout">Secure Boot</a>&quot; and key ROM layout</li>
</ul>
<h1><a class="header" href="#system-arguments" id="system-arguments">System Arguments</a></h1>
<p>The loader and kernel use a tagged format for defining system arguments. This tagged structure is designed to be small, and only describes data. The structure does not include any executable data. Instead, it contains references to this data that may be located immediately after the structure on a storage medium.</p>
<p>The tagged structure defines a prefix that is tagged by an 8-byte structure:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Tag {
    /// Ascii-printable name, not null-terminated, in little endian format.
    tag: u32,

    /// CRC16 of the data section, using CCITT polynomial.
    crc16: u16,

    /// Size of the data section, in 4-byte words.
    size: u16,
}
<span class="boring">}
</span></code></pre></pre>
<p>Tags are stored sequentially on disk, meaning a reader can skip over tags that it does not recognize. Furthermore, it can use a combination of <code>crc16</code> and <code>size</code> to determine that it has found a valid section.</p>
<p>The <code>size</code> field is in units of 4-bytes. Therefore, a <code>Tag</code> that contains only four bytes of data (for a total of 12-bytes on disk including the <code>Tag</code>) would have a <code>size</code> value of <code>1</code>.</p>
<h2><a class="header" href="#xarg-tag----xous-arguments-meta-tag" id="xarg-tag----xous-arguments-meta-tag"><code>XArg</code> tag -- Xous Arguments Meta-Tag</a></h2>
<p>The only ordering requirement for tags is that the first tag should be an <code>XArg</code> tag. This tag indicates the size of the entire structure as well as critical information such as the size of RAM.</p>
<p>Future revisions may add to this tag, however the size will never shrink.</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>4</td><td>Arg Size</td><td>The size of the entire args structure, including all headers, but excluding any trailing data (such as executables)</td></tr>
<tr><td>4</td><td>4</td><td>Version</td><td>Version of the XArg structure.  Currently <code>1</code>.</td></tr>
<tr><td>8</td><td>4</td><td>RAM Start</td><td>The origin of system RAM, in bytes</td></tr>
<tr><td>12</td><td>4</td><td>RAM Size</td><td>The size of system RAM, in bytes</td></tr>
<tr><td>16</td><td>4</td><td>RAM Name</td><td>A printable name for system RAM</td></tr>
</tbody></table>
<h3><a class="header" href="#xkrn-tag----xous-kernel-description" id="xkrn-tag----xous-kernel-description"><code>XKrn</code> tag -- Xous Kernel Description</a></h3>
<p>This describes the kernel image.  There must be exactly one <code>XKrn</code> tag in an arguments structure.
This image will get mapped into every process within the final 4 megabytes, and therefore the text and data
offsets must be in the range <code>0xffc0_0000</code> - <code>0xfff0_0000</code>.</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>4</td><td>LOAD_OFFSET</td><td>Physical address (or offset) where the kernel is stored</td></tr>
<tr><td>4</td><td>4</td><td>TEXT_OFFSET</td><td>Virtual memory address where the kernel expects the program image to live.  This should be <code>0xffd00000</code>.</td></tr>
<tr><td>8</td><td>4</td><td>TEXT_SIZE</td><td>Size of the text section.  This indicates how many bytes to copy from the boot image.</td></tr>
<tr><td>12</td><td>4</td><td>DATA_OFFSET</td><td>Virtual memory address where the kernel expects the .data/.bss section to be.  This should be above <code>0xffd00000</code> and below  <code>0xffe00000</code></td></tr>
<tr><td>16</td><td>4</td><td>DATA_SIZE</td><td>Size of the .data section</td></tr>
<tr><td>20</td><td>4</td><td>BSS_SIZE</td><td>The size of the .bss section, which immediately follows .data</td></tr>
<tr><td>24</td><td>4</td><td>ENTRYPOINT</td><td>Virtual address of the <code>_start()</code> function</td></tr>
</tbody></table>
<p>The kernel will run in Supervisor mode, and have its own private stack. The address of the stack will be generated by the loader.</p>
<h3><a class="header" href="#inie-tag----initial-elf-programs" id="inie-tag----initial-elf-programs"><code>IniE</code> tag -- Initial ELF Programs</a></h3>
<p>The <code>IniE</code> tag describes how to load initial processes.  There is one <code>IniE</code> for each initial program. There must be at least one <code>IniE</code> tag.</p>
<p>This tag has the following values:</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>4</td><td>LOAD_OFFSET</td><td>Position in RAM relative to the start of the arguments  block where this program is stored, or an absolute value if <code>ABSOLUTE</code>  is <code>1</code>.</td></tr>
<tr><td>4</td><td>4</td><td>ENTRYPOINT</td><td>Virtual memory address of the <code>_start()</code> function</td></tr>
</tbody></table>
<p>Following this is a list of <em>section definitions</em>. Section definitions must be sequential in RAM -- that is, it is not permitted for <code>SECTIONn_OFFSET</code> to decrease.
| Offset | Size | Name            | Description                                  |
| ------ | ---- | --------------- | -------------------------------------------- |
| n<em>3+8  | 8    | SECTIONn_OFFSET | Virtual memory address of memory section <em>n</em> |
| n</em>3+12 | 3    | SECTIONn_SIZE   | Size of memory section <em>n</em>                   |
| n*3+15 | 1    | SECTIONn_FLAGS  | Flags describing memory section <em>n</em>          |</p>
<p>The fields <code>size</code>, <code>flags</code>, and <code>offset</code> together occupy 64 bits (8 bytes). The
<code>OFFSET</code> is a full 32-bit address.  The <code>SIZE</code> field is in units of
bytes, however as it is only 24 bits, meaning the largest section size
is <code>2^24</code> bytes.</p>
<p>The <code>FLAGS</code> field contains the following four bits.  Any region may be
marked NOCOPY, however RISC-V does not allow regions to be marked
&quot;Write-only&quot;:</p>
<table><thead><tr><th>Bit</th><th>Binary</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>0b0001</td><td>NOCOPY</td><td>No data should be copied -- useful for <code>.bss</code></td></tr>
<tr><td>1</td><td>0b0010</td><td>WRITABLE</td><td>Region will be allocated with the &quot;W&quot; bit</td></tr>
<tr><td>2</td><td>0b0100</td><td>READABLE</td><td>Region will be allocated with the &quot;R&quot; bit</td></tr>
<tr><td>3</td><td>0b1000</td><td>EXECUTABLE</td><td>Region will be allocated with the &quot;X&quot; bit</td></tr>
</tbody></table>
<p>Programs <strong>cannot</strong> access the final four megabytes, as this memory
is reserved for the kernel. It is an error if any section enters this memory region.</p>
<h3><a class="header" href="#pnam-tag----program-names" id="pnam-tag----program-names"><code>PNam</code> Tag -- Program Names</a></h3>
<p><code>PNam</code> maps process IDs to process names. If multiple <code>PNam</code> tags exist
within a block, the first one that is encountered should take precedence.
This tag is a series of entries that take the following format:</p>
<table><thead><tr><th>Size (bytes)</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>4</td><td>PID</td><td>ID of the process that this name describes</td></tr>
<tr><td>4</td><td>Length</td><td>The length of the data that follows</td></tr>
<tr><td>varies</td><td>Data</td><td>The UTF-8 name string</td></tr>
</tbody></table>
<h3><a class="header" href="#bflg-tag----boot-flags" id="bflg-tag----boot-flags"><code>Bflg</code> Tag -- Boot Flags</a></h3>
<p>This configures various bootloader flags.  It consists of a single word
of data with various flags that have the following meaning:</p>
<ul>
<li>0x00000001 <code>NO_COPY</code>  -- Skip copying data to RAM.</li>
<li>0x00000002 <code>ABSOLUTE</code> -- All program addresses are absolute.
Otherwise, they're relative to the start of the config block.</li>
<li>0x00000004 <code>DEBUG</code>    -- Allow the kernel to access memory inside user
programs, which allows a debugger to run in the kernel.</li>
</ul>
<h3><a class="header" href="#mrex-tag----additional-memory-regions" id="mrex-tag----additional-memory-regions"><code>MREx</code> Tag -- Additional Memory Regions</a></h3>
<p>This tag defines additional memory regions beyond main system memory. This region omits main system memory, which is defined in the <code>XArg</code> tag.
The format for this tag consists of a single word defining how many additional sections there are, followed by actual section entries:</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>4</td><td>Count</td><td>The number of additional memory entries</td></tr>
</tbody></table>
<p>Each additional memory entry is 3 words of 4-bytes each:</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>n*3 + 4</td><td>4</td><td>Start</td><td>The start offset of this additional region</td></tr>
<tr><td>n*3 + 8</td><td>4</td><td>Length</td><td>The length of this additional region</td></tr>
<tr><td>n*3 + 12</td><td>4</td><td>Name</td><td>A 4-character name of this region that should be printable -- useful for debugging</td></tr>
</tbody></table>
<p>Additional memory regions should be non-overlapping. Creating overlapping memory regions will simply waste memory, as the loader will allocate multiple regions to track the memory yet will only allow it to be shared once.</p>
<h1><a class="header" href="#xous-loader" id="xous-loader">Xous Loader</a></h1>
<p>The Xous loader is located in the <a href="https://github.com/betrusted-io/xous/tree/main/loader">loader/</a> directory. This program runs in Machine mode, and makes the following assumptions:</p>
<ol>
<li>There is an Argument structure located somewhere in memory and register <code>$a0</code> points to it</li>
<li>The system has 16 MB of RAM and it is located at address <code>0x40000000</code></li>
</ol>
<p>Point #2 is flexible, and the loader has the ability to read the memory configuration out of the Argument structure, if one can accept trusting these parameters before the Argument structure is checked. However, in the current implementation, these values are hard-coded into the loader binary so that they are derived from an already verified, trusted location (see Loader Signature Checking below for why this is the case).</p>
<p>After passing the signature check, the loader runs the main loader sequence. The loader runs in two stages. The first stage is responsible for determining how much memory is required for each initial process as well as the kernel, and loading them into memory. The second stage sets up the platform-specific page tables.</p>
<h2><a class="header" href="#signature-checking-the-kernel" id="signature-checking-the-kernel">Signature Checking the Kernel</a></h2>
<p>We do not discuss precisely how we come to trust the loader itself: this responsibility falls onto a bootloader that is assumed to be burned into the ROM of the SoC running Xous. Please refer to <a href="https://github.com/betrusted-io/betrusted-wiki/wiki/How-Does-Precursor-Get-to-the-Reset-Vector%3F">this page</a> for an example of one implementation for getting to the reset vector. It turns out in Precursor that the process to check the loader is identical to that of checking the kernel.</p>
<p>Loader conditions #1 and #2, as outlined above, are set up by the bootloader. The following context is helpful to appreciate why we hard-code the RAM address and offset instead of reading it out of the loader Arguments:</p>
<ul>
<li>The Arguments to the loader describe the location and size of Kernel objects, in addition to encoding the amount and location of RAM</li>
<li>The loader and its Arguments are located in FLASH, so that it may be updated</li>
<li>It is expensive and hard to update the loader's digital signature recorded in the SoC, as it is often burned to a bank of OTP fuses</li>
<li>We assume that Kernel updates are routine, but loader updates are infrequent</li>
</ul>
<p>Because the Arguments are tightly coupled to the Kernel image, we cannot check them at the same time that the loader binary. Therefore, we must treat the Arguments as untrusted at the entry point of the loader, and ask the loader to verify the Arguments. However, the loader needs to know its location and extent of RAM to run any Argument checking. Thus this presents a circular dependency: how are we to know where our memory is, when the structure that describes our memory is designed to be changed frequently? The method chosen to break this circular dependency is to hard-code the location and amount of RAM in the loader binary itself, thus allowing the Arguments that describe the kernel to be malleable with a signature check stored in FLASH.</p>
<p>Signatures for both the loader and the kernel share a common structure. They consist of two sections: the detached signature, and the signed data itself. The detached signature has the following format in memory:</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>4</td><td>Version</td><td>Version number of the signature record. Currently <code>1</code></td></tr>
<tr><td>4</td><td>4</td><td>Length</td><td>Length of the signed region (should be exactly +4 over the Length field in the signed region)</td></tr>
<tr><td>8</td><td>64</td><td>Signature</td><td>64-byte Ed25519 signature of the signed region</td></tr>
<tr><td>12</td><td>pad</td><td>Padding</td><td>0-pad up to 4096 bytes</td></tr>
</tbody></table>
<p>The signed region has the following format:</p>
<table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>len(payload)</td><td>Payload</td><td>The signed payload (loader or kernel)</td></tr>
<tr><td>len(payload)</td><td>4</td><td>Version</td><td>A repeat of the version number of the signature record</td></tr>
<tr><td>len(payload)+4</td><td>4</td><td>Length</td><td>len(payload) + 4 = length of all the data up to this point</td></tr>
</tbody></table>
<p>Exactly every byte in the signed region, including the Version and Length, are signed. By including the Version and Length field in the signed region, we can mitigate downgrade and length extension attacks.</p>
<p>Signatures are computed using the <a href="https://github.com/dalek-cryptography/ed25519-dalek">Dalek Cryptography Ed25519</a> crate.</p>
<p>The public key used to check the signature can come from one of three sources:</p>
<ol>
<li>A self-generated key. This is the &quot;most trusted&quot; source. Ultimately, every device should self-sign its code.</li>
<li>A third-party key. We do not handle the thorny issue of who provides the third party key, or how we come about to trust it.</li>
<li>A developer key. This is a &quot;well known&quot; key which anyone can use to sign an image.</li>
</ol>
<p>The loader will attempt to verify the kernel image, in sequence, with each of the three keys. If it fails to find any image that matches, it prints an error message to the display and powers the system down after a short delay.</p>
<p>If the image is signed with anything but the self-generated key, a visible marker (a set of fine dashed lines over the status bar) is turned on, so that users are aware that there could be a potential trust issue with the boot images. This can be rectified by re-computing a self-signature on the images, and rebooting.</p>
<p>Upon the conclusion of the signature check, the loader also does a quick check of the stack usage, to ensure that nothing ran out of bounds. This is important because the Kernel assumes that no memory pages are modified across a suspend/resume, except for the (currently) two pages of RAM allocated to the loader's stack.</p>
<h2><a class="header" href="#reading-initial-configuration" id="reading-initial-configuration">Reading Initial Configuration</a></h2>
<p>The loader needs to know basic information about the Arguments structure before it can begin. This includes information about the memory layout, extra memory regions, kernel offset, and the number of initial programs.</p>
<p>The loader performs one pass through the Arguments structure to ensure that it contains the required fields before continuing.</p>
<h2><a class="header" href="#loader-stage-1-accounting" id="loader-stage-1-accounting">Loader Stage 1: Accounting</a></h2>
<p>The first stage goes through the Arguments structure and does initial accounting. This involves multiple passes over the arguments structure.</p>
<h3><a class="header" href="#runtime-page-tracker" id="runtime-page-tracker">Runtime Page Tracker</a></h3>
<p>The first pass sets up the <em>Runtime Page Tracker</em>. Each valid page in the system can be assigned to exactly one process. Memory that does not have an entry in the <em>Runtime Page Tracker</em> cannot be allocated, preventing us from allowing aliased memory.</p>
<p>Each page in main memory as well as each page in memory-mapped IO will get one byte of data in the <em>Runtime Page Tracker</em>. This byte indicates the process ID that the memory is assigned to. Process ID <code>0</code> is invalid, and indicates the page is free.</p>
<p>Whenever a page is allocated in the loader, it is marked in this region as belonging to the kernel -- i.e. PID 1. This region is passed to the kernel which will continue to use it to keep track of page allocations.</p>
<p>This memory is zeroed out and will be filled in later.</p>
<h3><a class="header" href="#process-allocation" id="process-allocation">Process Allocation</a></h3>
<p>The loader allocates a set of initial processes, and it must pass this list of processes to the kernel. Fundamentally a process is just three things:</p>
<ol>
<li>A memory space</li>
<li>An entrypoint</li>
<li>A stack</li>
</ol>
<p>As such, the loader needs to allocate a table with these three pieces of information that is large enough to fit all of the initial processes. Therefore, it allocates a slice of memory that contains an <code>InitialProcess</code> struct that is big enough to cover all of the initial processes.</p>
<p>This structure is zeroed out, and will be filled in later.</p>
<h3><a class="header" href="#argument-copying" id="argument-copying">Argument Copying</a></h3>
<p>The Arguments structure may be in RAM, but it may be located in some other area that will become inaccessible when the system is running. If configured, the Arguments structure is copied into RAM.</p>
<h3><a class="header" href="#process-copying" id="process-copying">Process Copying</a></h3>
<p>Each process, plus the kernel, is then copied into RAM.</p>
<p>This is complex due to how memory data is laid out. For example, some sections are labeld NOCOPY, and indicate data such as <code>.bss</code> where there is no actual data to copy, it must simply be zeroed out.</p>
<h3><a class="header" href="#setting-page-ownership" id="setting-page-ownership">Setting page ownership</a></h3>
<p>Mark all loader pages as being owned by <code>PID 1</code>. This ensures they cannot be reallocated later on.</p>
<h2><a class="header" href="#loader-stage-2-setting-page-tables" id="loader-stage-2-setting-page-tables">Loader Stage 2: Setting Page Tables</a></h2>
<p>Now that memory has been copied, the second stage is responsible for parsing the loader file and setting up the system-specific page tables.</p>
<p>The loader walks the Arguments structure again and loops through each initial process as well as the kernel. For each process, it allocates the root page table, sets up the various memory sections with their requested permissions, allocates a stack, and marks all memory as loaded by the correct process.</p>
<p>After this is done, the loader maps all of the loader-specific sections into the kernel's memory space. In particular, the following are all mapped directly:</p>
<ul>
<li>Arguments structure</li>
<li>Initial process list</li>
<li>Runtime page tracker</li>
</ul>
<h2><a class="header" href="#jumping-to-the-kernel" id="jumping-to-the-kernel">Jumping to the Kernel</a></h2>
<p>The loader runs in Machine mode, which means the MMU is disabled. As soon as the loader jumps to the kernel, the CPU enters Supervisor mode with the MMU enabled and never again returns to Machine mode.</p>
<p>The loader stashes these settings in a structure called <code>backup_args</code>. This structure is currently placed at the end of loader stack, however in the future it may be allocated alongside structures such as the runtime page tracker.</p>
<p>Execution continues in <code>start_kernel</code>, which is located in <code>asm.S</code>.</p>
<p>In order to allow interrupts and exceptions to be handled by the kernel, the loader sets <code>mideleg</code> to <code>0xffffffff</code> in order to delegate all interrupts to Supervisor mode, and it sets <code>medeleg</code> to <code>0xffffffff</code> in order to delegate all CPU exceptions to the kernel.</p>
<p>The loader then does the handover by setting <code>mepc</code> and issuing a <code>reti</code> Return from Interrupt opcode.</p>
<h2><a class="header" href="#resuming-from-suspend" id="resuming-from-suspend">Resuming from Suspend</a></h2>
<p>The operating system supports resuming from a cold poweroff. In order to get into this state, a program in the operating system wrote some values into RAM, then issued a command to power of the CPU in the middle of an interrupt handler.</p>
<p>A system is considered to be suspended when RAM contains a valid group of murmur3-signed hashes located at the 3rd page from the end of memory. If these hashes match, then the system is considered to be in suspend.</p>
<p>The loader then skips all remaining setup, because setup was previously performed and the system is in a live state. Indeed, if the loader tried to set up the data section of processes again, it would overwrite any volatile data in RAM.</p>
<p>In order to resume, the loader triggers a <code>STATE_RESUME</code> interrupt. This interrupt is not handled yet, since interrupts are not enabled. Instead, this interrupt will stay triggered until the kernel unmasks them, at which point the kernel will resume execution in the <code>susres</code> server and process the resume.</p>
<p>It then calls the kernel with arguments similar to a full boot. It reads values from the <em>backup_args</em> array located at the bottom of stack.</p>
<p>There is one change, however. Instead of beginning inside the kernel <em>main</em> function, the kernel begins executing immediately at the previous process. This causes the kernel to skip its initialization, and the kernel will resume where it left off once the preemption timer resumes.</p>
<h1><a class="header" href="#minielf-file-format" id="minielf-file-format">MiniELF File Format</a></h1>
<p>The loader uses a miniature version of the ELF file format.</p>
<p>ELF files support multiple sections. These sections have various flags, and may contain executable code, data, nothing, or debug information.</p>
<p>Traditional embedded programming relies on linker scripts to copy executable code into a format that can be programmed. Because Xous utilises an MMU, we can use ELF files natively.</p>
<p>A problem with the ELF format is that it contains a lot of overhead. The miniaturised version used here reduces the file size considerably while making it easier for the program to be loaded.</p>
<h2><a class="header" href="#program-header" id="program-header">Program Header</a></h2>
<p>The program header contains just two pieces of information: The <em>load_offset</em>, and the <em>entrypoint</em>.</p>
<p>The <em>load_offset</em> is the offset, relative to the start of the Arguments structure, where various sections are stored. That is, if a section indicates that it is loading from address <code>0x100</code>, then the actual physical address can be calculated as:</p>
<ul>
<li><code>0x100</code> * offset_of(arguments_list) + minielf.load_offset</li>
</ul>
<p>The <em>entrypoint</em> is simply the value of the program counter when the program is first started.</p>
<h2><a class="header" href="#section-headers" id="section-headers">Section Headers</a></h2>
<p>Following the Program Header is one or more Section Headers. The ELF format supports multiple section types, and does not have a fixed data/text/bss split, instead preferring a series of flags and values. The Xous image creation process opens the ELF file for each initial program and scans its section list. It skips any section that isn't required for running -- for example, symbol names, compile-time information, and debug information.</p>
<p>If a section is required for running and has no data -- for example if it's a <code>.bss</code> section -- then it sets the <code>NOCOPY</code> flag. Otherwise, data will get copied.</p>
<p>It then sets the <code>EXECUTE</code> and/or <code>WRITE</code> flags according to the ELF header.</p>
<p>Finally, it creates a new section entry in the Arguments structure with the specified flags, offset, and size. The offset used here is relative to the start of the output image on disk. Therefore, the very first section to be written will have an offset of <code>0</code>.</p>
<h2><a class="header" href="#elf-flags" id="elf-flags">ELF Flags</a></h2>
<p>ELF supports multiple flags. For example, it is possible to mark a section as <code>Executable</code>, <code>Read-Only</code>, or <code>Read-Write</code>. Unfortunately these flags don't work well in practice, and issues can arise from various permissions problems.</p>
<p>Xous currently marks all pages <code>Read-Write-Execute</code>, however this may change in the future.</p>
<h2><a class="header" href="#flattened-minielf" id="flattened-minielf">Flattened MiniELF</a></h2>
<p>The flattened MiniELF format is currently theoretical. This format would expand the on-disk representation of a process such that it was page-aligned. For example, in the storage format, offset <code>0x100</code> may be loaded to memory location <code>0x20000000</code>, while offset <code>0x110</code> may be loaded to offset <code>0x40000000</code>. The MMU is unable to create such fine-grained mappings, however a <code>Flattened MiniELF</code> file would reorder this such that the first memory location is stored at offset <code>0x1000</code> on the disk, allowing that entire page to be mapped to offset <code>0x20000000</code>. Padding will be added, and the subsequent data would be stored at offset <code>0x2000</code>. This allows the next page to be cleanly mapped to <code>0x40000000</code>.</p>
<p>This format will allow Execute-in-Place from SPI flash, which will free up additional memory.</p>
<h1><a class="header" href="#xous-build-system-overview" id="xous-build-system-overview">Xous Build System Overview</a></h1>
<p>The Xous build system uses the <code>xtask</code> concept to perform complex tasks without needing an external build system.</p>
<p>The <code>xtask</code> concept is simply an alias under <code>.cargo/config</code> that turns <code>cargo xtask</code> into <code>cargo run --package xtask --</code>.</p>
<p>Therefore, all complex operations from building the kernel to constructing an output image are handled by <code>xtask/src/main.rs</code>, which is compiled and run as a normal Rust program.</p>
<h2><a class="header" href="#building-images" id="building-images">Building Images</a></h2>
<p>Generally, users will want to use <code>cargo xtask app-image [app 1] [app ..]</code> to build a Xous image that contains the desired list of applications. The applications are the names of crates contained in the &quot;apps/&quot; directory.</p>
<p>There are also convenience commands to build emulation images, such as <code>cargo xtask run</code> (for hosted mode, where Xous runs directly on your native OS) and <code>cargo xtask renode-image</code> (for a Renode image, where a cycle accurate simulation can be run inside the Renode emulator). See Chapter 4 for more information about Renode.</p>
<h2><a class="header" href="#the-internal-flow-of-the-build-system" id="the-internal-flow-of-the-build-system">The Internal Flow of the Build System</a></h2>
<p>For those curious as to what the builder does on the inside, here is the general flow of most build operations.</p>
<h3><a class="header" href="#step-0-build-the-build-system" id="step-0-build-the-build-system">Step 0: Build the Build System</a></h3>
<p>When you type <code>cargo xtask</code>, the build system will compile <code>xtask/src/main.rs</code>. This happens automatically.</p>
<h3><a class="header" href="#step-1-build-the-kernel" id="step-1-build-the-kernel">Step 1: Build the Kernel</a></h3>
<p>The build system runs <code>cargo build --package kernel --release --target riscv32imac-unknown-xous-elf</code> in the <code>kernel/</code> directory.</p>
<h3><a class="header" href="#step-2-build-the-initial-programs" id="step-2-build-the-initial-programs">Step 2: Build the Initial Programs</a></h3>
<p>The build system runs <code>cargo build --target riscv32imac-unknown-xous-elf</code> with every initial program appended as a <code>--package</code> argument.</p>
<h3><a class="header" href="#step-3-build-the-loader" id="step-3-build-the-loader">Step 3: Build the Loader</a></h3>
<p>The build system runs <code>cargo build --target riscv32imac-unknown-xous-elf --package loader</code> in the <code>loader/</code> directory.</p>
<h3><a class="header" href="#step-4-package-it-all-up" id="step-4-package-it-all-up">Step 4: Package it all Up</a></h3>
<p>The build system runs <code>cargo run --package tools --bin create-image --</code> followed by arguments to create the image.</p>
<h1><a class="header" href="#testing-crates" id="testing-crates">Testing Crates</a></h1>
<p>Cargo contains a built-in test runner. You can annotate functions with <code>#[test]</code> to indicate functions that should only be run in test mode:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn exploration() {
    assert_eq!(2 + 2, 4);
}
<span class="boring">}
</span></code></pre></pre>
<p>When you run <code>cargo test</code>, the build system will wrap each of these functions in a test harness and run them all in sequence. Importantly, these tests are all run in the same process, because the test harness is just an ordinary program with multiple &quot;main&quot; functions linked in.</p>
<h2><a class="header" href="#testing-crates-on-xous" id="testing-crates-on-xous">Testing Crates on Xous</a></h2>
<p>The <code>cargo test</code> subcommand accepts a <code>--target</code> flag, as well as the <code>--no-run</code> flag to prevent actually running the code. All we have to do is compile tests for our target, then run that executable on real hardware or in Renode:</p>
<pre><code class="language-sh">$ cargo test --target=riscv32imac-unknown-xous-elf --no-run
    Finished test [unoptimized + debuginfo] target(s) in 0.07s
  Executable unittests src/lib.rs (target/riscv32imac-unknown-xous-elf/debug/deps/gdbstub-7542e01db3053fd1)
$
</code></pre>
<p>By running this, the build system has created an ELF executable that we can load onto real hardware. The easiest way to incorporate it into real hardware is to use the <code>libstd-test</code> target as part of core:</p>
<pre><code class="language-sh">$ cd ../xous-core/
$ cargo xtask libstd-test ../gdbstub/target/riscv32imac-unknown-xous-elf/debug/deps/gdbstub-7542e01db3053fd1
$
</code></pre>
<p>You can then run the resulting image in Renode or on real hardware</p>
<p><img src="images/cargo-test-renode.jpg" alt="Renode running Test" /></p>
<h1><a class="header" href="#xous-image-creation" id="xous-image-creation">Xous Image Creation</a></h1>
<p>Xous image creation is primarily performed by the <code>create-image</code> program. This program bundles memory definitions, the kernel, and initial programs together and generates an image on-disk suitable for passing to the loader.</p>
<p>You can run this program manually to see how it works:</p>
<pre><code class="language-sh">$ cargo run -p tools --bin create-image -- --help
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
     Running `target/debug/create-image --help`
Xous Image Creator 0.1.0
Sean Cross &lt;sean@xobs.io&gt;
Create a boot image for Xous

USAGE:
    create-image [FLAGS] [OPTIONS] &lt;OUTPUT&gt; --csv &lt;CSR_CSV&gt; --kernel &lt;KERNEL_ELF&gt; --ram &lt;OFFSET:SIZE&gt; --svd &lt;SOC_SVD&gt;

FLAGS:
    -d, --debug      Reduce kernel-userspace security and enable debugging programs
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -c, --csv &lt;CSR_CSV&gt;          csr.csv file from litex
    -i, --init &lt;init&gt;...         Initial program to load
    -k, --kernel &lt;KERNEL_ELF&gt;    Kernel ELF image to bundle into the image
    -r, --ram &lt;OFFSET:SIZE&gt;      RAM offset and size, in the form of [offset]:[size]
    -s, --svd &lt;SOC_SVD&gt;          soc.csv file from litex

ARGS:
    &lt;OUTPUT&gt;    Output file to store tag and init information
$
</code></pre>
<p>This program generates an <a href="ch05-01-arguments.html">Arguments structure</a> based on the specified commands, and copies data from the given ELF files into an area immediately following this structure. In this manner, a complete, position-independent loadable system is generated in a single binary image.</p>
<p>This program also does rudimentary sanity checking. For example, it will ensure the kernel is loaded at a sane offset -- namely above address <code>0xff000000</code>. It will also ensure the memory regions don't overlap.</p>
<p>As a special case, it will trim the CSR section down from the reported size. In essence, while the configuration region is defined as 256 MB wide, this large region is never used in practice. In order to reduce the amount of memory required to store this data, as well as in order to remove memory aliasing attacks, the CSR region is trimmed down from the reported value to only encompass ranges that are valid.</p>
<h2><a class="header" href="#the-kernel-and-initial-programs" id="the-kernel-and-initial-programs">The Kernel and Initial Programs</a></h2>
<p>The kernel, as well as each initial program, are all packaged together in the same <code>args.bin</code> file. In order to do this, <code>create-image</code> operates in a two-pass fashion.</p>
<p>To begin with, all tags are created and lumped together. This is done first by calling <code>finalize()</code> on each tag, followed by writing them all out to disk. The <code>finalize()</code> call allows tags to update internal fields, but does not allow tags to change their size at all.</p>
<p>The <code>finalize()</code> argument takes a single argument, which describes how many additional bytes have been added to the args structure. This function may do nothing, in which case it returns zero. It may also request that additional data be added to the output, in which case it should return a nonzero value.</p>
<p>After all tags have been written, the <code>last_data()</code> function is called for each tag. This allows the tag to append data to the end of the structure.</p>
<p>An example of tags that do this include the kernel and the initial programs. They return the size of their payload in the <code>finalize()</code> call. They also use this call to update the tag data prior to writing it out.</p>
<p>They also write the actual contents of the tag during the <code>last_data()</code> call.</p>
<h1><a class="header" href="#messages-and-message-passing" id="messages-and-message-passing">Messages and Message Passing</a></h1>
<p>Messages form the basis of interprocess communication on Xous. A process exists in isolation and can only communicate to the outside world by sending messages. The limited API provided by the kernel means that almost all interactions are provided by userspace Servers, which must be communicated with using Messages.</p>
<p><img src="images/messaging-arch.png" alt="overview of message passing" /></p>
<h2><a class="header" href="#connecting-to-and-disconnecting-from-servers" id="connecting-to-and-disconnecting-from-servers">Connecting to and Disconnecting from Servers</a></h2>
<p>To connect to a server you must supply it an <code>Server ID</code>. A <code>Server ID</code> is a 16-byte value of some sort that is shared in a universal namespace. If you know a Server's <code>Server ID</code> then you can connect to that Server.</p>
<p>There are a few well-known <code>Server ID</code>s. These include bare minimum IDs that are required by any process to do anything useful. They are:</p>
<ul>
<li><em>b&quot;xous-log-server &quot;</em>: Output log messages to the console, as well as basic <code>println!()</code> support</li>
<li><em>b&quot;ticktimer-server&quot;</em>: Used for <code>sleep()</code> as well as time-based Mutexes</li>
<li><em>b&quot;xous-name-server&quot;</em>: A central nameserver that is used for connecting to all other servers</li>
</ul>
<p>To connect to a Server, call <code>xous::connect()</code>. For example, to connect to the <code>ticktimer-server</code>, call:</p>
<pre><code class="language-cs">let connection_id = xous::connect(xous::SID::from_bytes(b&quot;ticktimer-server&quot;).unwrap())?;
</code></pre>
<p>This will provide you a Connection to that server. If the Server is not available, the call will block until it is created. To fail if the server does not exist, use <code>try_connect()</code> instead of <code>connect()</code>.</p>
<h2><a class="header" href="#connection-limitations" id="connection-limitations">Connection Limitations</a></h2>
<p>Connections are limited on a per-process basis. Each process may only establish a connection to at most 32 servers. When this number is exceeded, <code>xous::connect()</code> will return <code>Error::OutOfMemory</code>.</p>
<p>If you call <code>xous::connect()</code> twice with the same <code>Server ID</code>, then you will get the same <code>connection_id</code>.</p>
<h2><a class="header" href="#disconnecting" id="disconnecting">Disconnecting</a></h2>
<p>To disconnect from a server, call <code>unsafe { xous::disconnect(connection_id)};</code>. This function is <code>unsafe</code> because you can copy connection IDs, so it is up to you to ensure that they are no longer in use when disconnecting.</p>
<p>For example, if you <code>connect()</code> to a Server and spawn a thread with that connection ID, you should only call <code>disconnect()</code> once that thread has finished with the connection. Similarly, if you <code>Copy</code> the connection ID to the thread, you must make sure that <strong>both</strong> uses of the Connection ID are destroyed prior to disposing of the connection.</p>
<p>Because of this, it is recommended that you use an <code>ARC&lt;CID&gt;</code> in order to ensure that the connection is only closed when it is no longer in use.</p>
<p>Furthermore, recall that subsequent calls to <code>connect()</code> with the same argument will reuse the <code>connection_id</code>. Because of this, it is vital that you only call <code>disconnect()</code> when you are certain that all instances are finished with the connection.</p>
<h2><a class="header" href="#message-overview" id="message-overview">Message Overview</a></h2>
<p>Messages come in five kinds: Scalar, BlockingScalar, Borrow, MutableBorrow, and Send. <code>Scalar</code> and <code>Send</code> messages are nonblocking and return immediately, while the others wait for the Server to respond.</p>
<p><code>Borrow</code>, <code>MutableBorrow</code>, and <code>Send</code> all detach memory from the client and send it to the server.</p>
<h2><a class="header" href="#scalar-and-blockingscalar-messages" id="scalar-and-blockingscalar-messages">Scalar and BlockingScalar Messages</a></h2>
<p>These messages allow for sending four <code>usize</code>s of data plus one <code>usize</code> of command. This can be used to send short updates to the Server. <code>Scalar</code> messages return to the client immediately, meaning the Server will receive the message after a short delay.</p>
<p><code>BlockingScalar</code> messages will pause the current thread and switch to the Server immediately. If the message is handled quickly, the Server can respond to the message and switch back to the Client before its quantum expires.</p>
<p><code>BlockingScalar</code> messages can return one or two <code>usize</code>s worth of data by returning <code>Result::Scalar1(usize)</code> or <code>Result::Scalar2(usize, usize)</code>.</p>
<p>As an example of what can be done, the ticktimer server uses <code>BlockingScalar</code> messages to implement <code>msleep()</code> by delaying the response until a timer expires.</p>
<h2><a class="header" href="#borrow-mutableborrow-and-send-messages" id="borrow-mutableborrow-and-send-messages">Borrow, MutableBorrow, and Send Messages</a></h2>
<p>These messages allow for sending memory from one process to another. Memory must be page-sized and aligned, but may be any memory available to a process. For example, a hardware process may want to reserve all MMIO peripherals in the system and then share them with processes as desired.</p>
<p>The memory message types allow for one <code>usize</code> worth of tag data which can be used to describe what the message is used for.</p>
<p>Furthermore, messages may also contain two advisory fields: <code>offset</code> and <code>valid</code>. These fields may be used to define an offset with the memory block where interesting data occurs. Similarly, the <code>valid</code> field could be used to define how large the data is.</p>
<p>When memory is passed via <code>MutableBorrow</code> then the memory is mapped into the Server's address space as writable. Additionally, the <code>offset</code> and <code>valid</code> fields become writable and may be updated in the server. As an example, if a Server implemented <code>bzero()</code> to clear a memory range to zero, then it might clear the contents of the buffer, then set both <code>offset</code> and <code>valid</code> to 0.</p>
<p>Internally, the <code>MutableBorrow</code> is updated by passing the new fields to <code>ReturnMemory()</code> where it gets updated in the client.</p>
<h1><a class="header" href="#xous-names" id="xous-names">Xous Names</a></h1>
<p>Servers are identified by a 128-bit ID number in Xous. Anyone with knowledge of the 128-bit ID number can make requests to that server.</p>
<p>Some servers have &quot;well-known names&quot;. These servers are designed to accept any number of connections and all of its APIs are considered safe for public use.</p>
<p>Other servers may have sensitive API calls. Their 128-bit IDs are treated as a secret.</p>
<p>In order to discover their ID, these servers register their ID in <code>xous-names</code>, along with a 64-byte <code>server name</code> which is a unique plaintext description of the server, and a <code>MaxConnections</code> which is the maximum number of processes allowed to connect to the registered server.</p>
<p><img src="images/xous-names.png" alt="overview of Xous names" /></p>
<h2><a class="header" href="#well-known-names" id="well-known-names">Well-Known Names</a></h2>
<p>A few servers have well-known names:</p>
<ul>
<li>log server: needed to debug name resolution issues</li>
<li>ticktimer: in case you want to delay before connecting to a server</li>
<li>Xous Names: the name server itself has a well known name</li>
<li>Some <code>std</code> library servers, which should not be connected to directly by user processes but instead through <code>libstd</code> calls.</li>
</ul>
<p>Well-known servers have a name like <code>b&quot;xous-name-server&quot;</code>, which reads like ASCII text but fits in exactly 128 bits: you just have to know the magic string, and you can connect to them.</p>
<p>Application programers will never need to know this name, because it is encapsulated within the objects that access the servers. For example, <code>XousNames::new()</code> &quot;just knows&quot; the name, so to access <code>xous-names</code> one simply needs to create a new <code>XousNames</code> object.</p>
<h2><a class="header" href="#discovered-names" id="discovered-names">Discovered Names</a></h2>
<p>All other servers have their names registered as a 64-byte free-from <code>u8</code> array, which by convention maps to ASCII text (nothing prevents you from doing weird things that don't map to unicode, but, please don't). The resulting server ID is a crytpographically random 128-bit ID, which makes it effectively unguessable. Note that no checks are done for collisions with the &quot;well known&quot; names, because the chance that the TRNG would output the string <code>b&quot;xous-name-server&quot;</code> by chance is vanishingly small.</p>
<p>When registering a server, one might invoke a call like this:</p>
<pre><code class="language-rust noplayground ignore">    let xns = xous_names::XousNames::new().unwrap();
    let net_sid = xns
        .register_name(api::SERVER_NAME_NET, None)
        .expect(&quot;can't register server&quot;);
</code></pre>
<p>or this:</p>
<pre><code class="language-rust noplayground ignore">    let xns = xous_names::XousNames::new().unwrap();
    let keys_sid = xns
        .register_name(api::SERVER_NAME_KEYS, Some(3))
        .expect(&quot;can't register server&quot;);
</code></pre>
<p>Generally, the server name is defined as a string within the <code>api.rs</code> section, so that other crates can refer to it via the API. In the case of the <code>net</code> crate, the maximum connection limit is <code>None</code>, which means that any processes may connect to the <code>net</code> crate. In the case of the <code>root keys</code> crate, the number of connections to it is limited to 3 by the <code>Some(3)</code> argument.</p>
<p>In this case, the first three processes that attempt to connect to the <code>root keys</code> crate are handed out it's 128-bit server ID. Later processes that attempt to connect will be denied. This is a &quot;trust on first use&quot; model similar to how SSH maps host public keys to IP addresses.</p>
<p>Generally, sensitive servers like <code>root keys</code> are encapsulated by other processes that act as firewalls to it. So, if there were a hypothetical need to dole out derived keys from the <code>root keys</code> set, a second <code>derived keys</code> server might be created which can accept any number of connections, and one more connection would be added to the <code>root keys</code> connection count for the <code>derived keys</code> server. The <code>derived keys</code> server would thus act as a firewall to the <code>root keys</code> server.</p>
<p>Furthermore, as a rule, the number of processes created by a system must be static and known on boot in order for this system to work. This is because the most secure operations will not be allowed to be conducted until all of the servers that have specified a connection limit have their connection tables fully occuppied. Therefore it is not allowed to, for example for the hypothetical <code>derived keys</code> to connect to the <code>root keys</code> server at some point during runtime, and then de-allocate its connection when it no longer needs it. Instead, <code>dervied keys</code> should eagerly connect to the <code>root keys</code> on boot so that it can reserve and permanently hold its slot in the connection table.</p>
<p>The goal of this is to disallow a rogue or unexpected process from connecting to sensitive servers through the Xous Names discovery mechanism.</p>
<h1><a class="header" href="#caller-idioms" id="caller-idioms">Caller Idioms</a></h1>
<p>There are two flavors of messages in Xous: <code>scalar</code> or <code>memory</code> messages. <code>scalar</code> messages are pass-by-register and have a limited size, but are very fast. <code>memory</code> messages are pass-by-memory, and can be large, but are slower.</p>
<p>There are (so far) four common types of caller patterns used in Xous:</p>
<ol>
<li>Non-synchronizing: these are &quot;fire and forget&quot; messages that don't block(*) and have no synchronization guarantee.</li>
<li>Synchronous: these block and wait for a response from the callee. The caller can do nothing else until this message is handled.</li>
<li>Asynchronous: these don't block, and expect a response at some time later via a &quot;push notification&quot;.</li>
<li>Deferred-response: these block the caller, but the callee is not allowed to block.</li>
</ol>
<p>Type (1) is implemented using <code>send</code> on <code>memory</code> messages, or vanilla <code>scalar</code> messages on <code>scalar</code> types.</p>
<p>The remaining types will involve a <code>lend</code> or <code>lend_mut</code> on <code>memory</code> messages, or <code>blocking_scalar</code> on <code>scalar</code> types.</p>
<p>Before diving in, it is helpful to review the <a href="ch07-00-messages.html">messaging architecture</a> of Xous:</p>
<p><img src="images/messaging-arch.png" alt="overview of message flow" /></p>
<p>Each server consists at its core of an event loop. While event loops are allowed to be non-blocking, this is an edge case and in general all event loops are blocking: when an event loop blocks, it is de-scheduled and consumes zero CPU resources, allowing us to stop the CPU clock and save power.</p>
<p>An incoming message will wake up the process, at which point the process shall decode and process the message. From here, the process may issue messages to other servers. Memory <code>send</code> and Scalar <code>scalar</code> messages will not stop the execution flow; the outgoing messages are simply placed in the destination queue and life goes on. However, blocking message types <code>lend</code>, <code>lend_mut</code>, and <code>blocking_scalar</code> will cause the message to be placed in the destination queue, and the current thread yields the remainder of its quanta to the destination thread. The blocked thread will remain stopped at that point of execution until the blocking message types are &quot;returned&quot;. At this point the blocked thread is re-queued for execution. Execution will resume either on a time-based pre-emption boundary, or possibly earlier if the returning process completes its task before its quanta is up and enters a blocking state (that is, waiting on a new incoming message, or a response to a new outgoing blocking message).</p>
<p>⚡ Key Concept ⚡</p>
<p>Memory messages implicitly return to callers on <code>Drop</code>. Thus, there is no explicit &quot;return&quot; call in Xous for memory messages. Thus, one must use Rust's borrow checker to schedule the return. Specifically:</p>
<ul>
<li>Synchronous messages return as soon as the current message goes out of scope, e.g., at the bottom of the event loop.</li>
<li>Deferred-response is implemented by binding the current message to an <code>Option&lt;MessageEnvelope&gt;</code> type that is external to the main event loop.
<ul>
<li>By sticking the message into a <code>Some()</code>, the message is not allowed to go out of scope, the <code>Drop</code> is never called, and thus the caller blocks.</li>
<li>However, the callee is free to continue on with its processing.</li>
<li>A return is triggered by calling <code>take()</code> on the enclosing <code>Option</code>. This moves the message out of the <code>Option</code> and into the current scope, where the message can now be modified with a return value. Once that operation ends, the message goes out of scope, <code>Drop</code> is called, and likewise, data is returned to the caller</li>
</ul>
</li>
</ul>
<p>⚠️ IPC Interoperability ⚠️</p>
<p>In many places Xous offers <code>usize</code> as arguments for IPC calls. This has a platform-dependent size, and in fact, the size can be different between caller and callee if you're passing messages between disparate hosts (which is actually a thing that is allowed on Xous).</p>
<p>For maximum compatibility, the recommendation is to restrict all IPC implementations to a <code>u32</code>-in-<code>usize</code>, unless you never intend to run on a 32-bit platform. <strong>Note</strong>: the target Precursor hardware is a 32-bit platform.</p>
<h2><a class="header" href="#basic-template" id="basic-template">Basic Template</a></h2>
<p>With this overview, we can now give an example of each of the four types of messages. In general, we assume that services are organized into at least three files:</p>
<ul>
<li><code>lib.rs</code> -- the caller-side API that formats native Rust data into IPC messages</li>
<li><code>main.rs</code> the server-side API that unpacks IPC messages and acts on them</li>
<li><code>api.rs</code> -- data structures &amp; definitions shared between caller and callee</li>
</ul>
<p>Note that none of these are mandatory -- for example, a pure client-side library like our AES implementation has only a <code>lib.rs</code>; and, an application that offers no services and has only a main function would have only a <code>main.rs</code>.</p>
<p>Below is an example of what these files might look like in a very minimal server implementation.</p>
<pre><code class="language-rust noplayground ignore">// inside lib.rs
pub mod api;
pub use api::*;
use xous::{CID, send_message};
use num_traits::*;
use core::sync::atomic::{AtomicU32, Ordering};
static REFCOUNT: AtomicU32 = AtomicU32::new(0);

pub struct MyService {
    conn: CID,
}
impl MyService {
    pub fn new() -&gt; Self {
        let xns = xous_names::XousNames::new().expect(&quot;couldn't connect to XousNames&quot;);
        REFCOUNT.fetch_add(1, Ordering::Relaxed);
        let conn = xns.request_connection_blocking(api::SERVER_NAME_MYSERVICE).expect(&quot;Can't connect to MyService&quot;);
        MyService {
            conn
        }
    }
    // ------ library methods to be discussed in detail below ------
}
/// Automatic disconnect on dropping the final instance of this connection
impl Drop for MyService {
    fn drop(&amp;mut self) {
        if REFCOUNT.fetch_sub(1, Ordering::Relaxed) == 1 {
            unsafe{xous::disconnect(self.conn).unwrap();}
        }
    }
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// inside api.rs
pub(crate) const SERVER_NAME_MYSERVICE: &amp;str     = &quot;_Any descriptive and unique name under 64 chars_&quot;;

#[derive(num_derive::FromPrimitive, num_derive::ToPrimitive, Debug)]
pub(crate) enum Opcode {
    /// Define various operations here
    DoNonSync,
    // ------ API opcodes to be discussed in detail below ------
    /// Exits the server
    Quit,
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// inside main.rs
#![cfg_attr(target_os = &quot;none&quot;, no_main)]

mod api;
use api::*;
use num_traits::*;

#[xous::xous_main]
fn xmain() -&gt; ! {
    log_server::init_wait().unwrap();
    log::set_max_level(log::LevelFilter::Info);
    log::info!(&quot;my PID is {}&quot;, xous::process::id());

    let xns = xous_names::XousNames::new().unwrap();
    let sid = xns.register_name(api::SERVER_NAME_MYSERVER, None).expect(&quot;can't register server&quot;);
    loop {
        let msg = xous::receive_message(sid).unwrap();
        match FromPrimitive::from_usize(msg.body.id()) {
            Some(Opcode::DoNonSync) =&gt; xous::msg_scalar_unpack!(msg, _, _, _, _, {
                // do stuff here
            }),
            // ------ options to be discussed in detail below ------
            Some(Opcode::Quit) =&gt; {
                xous::return_scalar(msg.sender, 1).expect(&quot;couldn't ack quit&quot;);
                break;
            },
            None =&gt; log::error!(&quot;couldn't convert opcode: {:?}&quot;, msg),
        }
    }
    // clean up our program
    xns.unregister_server(sid).unwrap();
    xous::destroy_server(sid).unwrap();
    xous::terminate_process(0)
}

</code></pre>
<p>With the above template in mind, click on the following for examples of each of the four patterns, broken down into each of <code>Scalar</code> and <code>Memory</code> types when applicable.</p>
<ul>
<li><a href="ch07-03-nonsynchronizing.html">Non-synchronizing</a></li>
<li><a href="ch07-04-synchronizing.html">Synchronous</a>. Includes an example of how to use raw messages (instead of <code>rkyv</code>) for serializing data.</li>
<li><a href="ch07-05-asynchronous.html">Asynchronous</a> or &quot;push notifications&quot;</li>
<li><a href="ch07-06-deferred.html">Deferred response</a></li>
<li><a href="ch07-07-forwarding.html">Forwarding messages</a></li>
</ul>
<h1><a class="header" href="#non-synchronizing-idioms" id="non-synchronizing-idioms">Non-Synchronizing Idioms</a></h1>
<h2><a class="header" href="#scalar-pattern" id="scalar-pattern">Scalar Pattern</a></h2>
<p>A scalar non-synchronizing call has the following characterisics:</p>
<ul>
<li>Up to 4 <code>u32</code>-sized arguments</li>
<li>Caller does not block</li>
<li>Callee does not return any result</li>
<li>No guarantee of synchronization between caller and callee
<ul>
<li>Side effects may happen at an arbitrary time later</li>
<li>Messages are guaranteed to arrive in order</li>
</ul>
</li>
</ul>
<pre><code class="language-rust noplayground">// api.rs
pub(crate) enum Opcode {
    Lights,
    // ... and other ops
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// lib.rs:
impl MyService {
    // ... new(), etc.

    /// Tell the main loop to set the state of lights. When this call exits, all we know is
    /// a message is &quot;en route&quot; to the main loop, but we can't guarantee anything has happened.
    pub fn set_lights(&amp;self, state: bool) -&gt; Result&lt;(), xous::Error&gt; {
        send_message(self.conn,
            Message::new_scalar(Opcode::Lights.to_usize().unwrap()),
                if state {1} else {0},
                0,
                0,
                0
            )
        ).map(|_|())
    }
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// main.rs:
fn xmain() -&gt; ! {
    // ... preamble
    loop {
        let msg = xous::receive_message(sid).unwrap();
        match FromPrimitive::from_usize(msg.body.id()) {
            /// This will get processed whenever the server gets scheduled, which has no strict
            /// relationship to the caller's state. However, messages are guaranteed
            /// to be processed in-order.
            Some(Opcode::Lights) =&gt; xous::msg_scalar_unpack!(msg, state, _, _, _, {
                if state == 1 {
                    turn_lights_on();
                } else {
                    turn_lights_off();
                }
            }),
            // .. other match statements
        }
    }
    // ... postamble
}
</code></pre>
<h2><a class="header" href="#memory-pattern" id="memory-pattern">Memory Pattern</a></h2>
<p>A memory non-synchronizing call has the following characterisics:</p>
<ul>
<li>Messages are sent in blocks rounded up to the nearest 4096-byte page size</li>
<li>Caller does not block</li>
<li>Callee does not return any result</li>
<li>No guarantee of synchronization between caller and callee
<ul>
<li>Side effects may happen at an arbitrary time later</li>
<li>Messages are guaranteed to arrive in order</li>
</ul>
</li>
</ul>
<pre><code class="language-rust noplayground ignore">// api.rs
pub(crate) enum Opcode {
    // use `rkyv` to serialize a memory message and send
    PushDataRkyv,
    // example of explicit serialization
    PushDataExplicit,
    // ... and other ops
}
/// `rkyv` can be used as a convenience method to serialize data in complex structures.
/// Almost any type can be contained in the structure (enums, other structures), but the
/// type must also `derive` the `rkyv` Archive, Serialize, and Deserialize traits.
/// Thus one cannot simply seralize a `std::string::String`; it must be transcribed into
/// a `xous_ipc::String::&lt;N&gt;` type which has a defined allocation size of `N`.
#[derive(rkyv::Archive, rkyv::Serialize, rkyv::Deserialize)]
pub struct CompoundData {
    pub data: [u8; 1000],
    pub len: u16,
    pub description: xous_ipc::String::&lt;128&gt;,
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// lib.rs:
impl MyService {
    // ... new(), etc.

    /// Send some `data` to the server. It'll get there when it gets there.
    /// This example uses `rkyv` to serialize data into a compound structure.
    pub fn push_data_rkyv(&amp;self, data: &amp;[u8], desc: &amp;str) -&gt; Result&lt;(), xous::Error&gt; {
        let mut rec = CompoundData {
            data: [0u8; 1000],
            len: 0,
            description: xous_ipc::String::new(),
        };
        if data.len() &gt; rec.data.len() {
            return Err(xous::Error::OutOfMemory);
        }
        for (&amp;s, d) in data.iter().zip(rec.data.iter_mut()) {
            *d = s;
        }
        data.len = data.len() as u16;
        rec.description.append(desc).ok(); // overflows are silently truncated

        // now consume `rec` and turn it into a Xous::Buffer, which can then be mapped into the
        // callee's memory space by `send`
        let buf = Buffer::into_buf(rec).or(Err(xous::Error::InternalError))?;
        buf.send(self.conn, Opcode::PushDataRkyv.to_u32().unwrap()).map(|_| ())
    }
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// main.rs:
fn xmain() -&gt; ! {
    // ... preamble
    let mut storage = Vec::&lt;CompoundData&gt;::new();
    let mut raw_data = [0u8; 32];
    loop {
        let msg = xous::receive_message(sid).unwrap();
        match FromPrimitive::from_usize(msg.body.id()) {
            /// This will get processed whenever the server gets scheduled, which has no strict
            /// relationship to the caller's state. However, messages are guaranteed
            /// to be processed in-order.
            Some(Opcode::PushDataRkyv) =&gt; {
                let buffer = unsafe { Buffer::from_memory_message(msg.body.memory_message().unwrap()) };
                // `.to_original()` automatically makes a copy of the data into my process space.
                //    This adds overhead and time, but your original types are restored.
                // `.as_flat()` will use the data directly out of the messages' memory space without copying it,
                //    but it introduces some type complexity. We don't give an example here, but you may find
                //    one in the TRNG's `FillTrng` implementation, where we avoid making two copies of the
                //    data for a more performant implementation.
                let data = buffer.to_original::&lt;PushDataRkyv, _&gt;().unwrap();
                storage.push(data);
            }
            // .. other match statements
        }
    }
    // ... postamble
}
</code></pre>
<h1><a class="header" href="#synchronizing" id="synchronizing">Synchronizing</a></h1>
<h2><a class="header" href="#scalar-pattern-1" id="scalar-pattern-1">Scalar Pattern</a></h2>
<p>A scalar synchronizing call has the following characterisics:</p>
<ul>
<li>Up to 4 <code>u32</code>-sized arguments</li>
<li>Caller blocks until the callee returns</li>
<li>Callee may return up to 2 <code>u32</code>-sized values</li>
</ul>
<pre><code class="language-rust noplayground">// api.rs
pub(crate) enum Opcode {
    LightsSync,
    // ... and other ops
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// lib.rs:
impl MyService {
    // ... new(), etc.

    /// Tell the main loop to set the state of lights. This blocks until we get a confirmation code,
    /// which in this case was the last state of the lights.
    pub fn set_lights_sync(&amp;self, state: bool) -&gt; Result&lt;bool, xous::Error&gt; {
        match send_message(self.conn,
            Message::new_blocking_scalar(Opcode::LightsSync.to_usize().unwrap()),
                if state {1} else {0},
                0,
                0,
                0
            )
        ) {
            // match to `xous::Result::Scalar2(val1, val2)` for the case of two values returned
            Ok(xous::Result::Scalar1(last_state)) =&gt; {
                if last_state == 1 {
                    Ok(true)
                } else {
                    Ok(false)
                }
            }
            _ =&gt; {
                Err(xous::Error::InternalError)
            }
        }
    }
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// main.rs:
fn xmain() -&gt; ! {
    // ... preamble
    loop {
        let msg = xous::receive_message(sid).unwrap();
        match FromPrimitive::from_usize(msg.body.id()) {
            Some(Opcode::LightsSync) =&gt; xous::msg_blocking_scalar_unpack!(msg, state, _, _, _, {
                let last_state = lights_current_state();
                if state == 1 {
                    turn_lights_on();
                } else {
                    turn_lights_off();
                }
                if last_state {
                    // alternative form is `xous::return_scalar2(msg.sender, val1, val2)`
                    xous::return_scalar(msg.sender, 1).expect(&quot;couldn't return last state&quot;);
                } else {
                    xous::return_scalar(msg.sender, 0).expect(&quot;couldn't return last state&quot;);
                }
            }),
            // .. other match statements
        }
    }
    // ... postamble
}
</code></pre>
<h2><a class="header" href="#memory-pattern-1" id="memory-pattern-1">Memory Pattern</a></h2>
<p>A memory synchronizing call has the following characterisics:</p>
<ul>
<li>Messages are sent in blocks rounded up to the nearest 4096-byte page size</li>
<li>Caller blocks until the data is returned</li>
<li>Callee returns data by overwriting the same page(s) of memory that were sent</li>
</ul>
<p>This example also shows how to do a memory message without <code>rkyv</code>. This is useful
for situations that can't have an <code>rkyv</code> dependency, or if you just prefer to do
things in a low-level fashion.</p>
<pre><code class="language-rust noplayground ignore">// api.rs
pub(crate) enum Opcode {
    // use `rkyv` to serialize a memory message and send
    PushDataRkyv,
    // example of explicit serialization
    PushDataExplicit,
    // ... and other ops
}
#[derive(rkyv::Archive, rkyv::Serialize, rkyv::Deserialize)]
pub struct CompoundData {
    pub data: [u8; 1000],
    pub len: u16,
    pub description: xous_ipc::String::&lt;128&gt;,
}
/// For a memory structure to be remapped between processes, it must be page-aligned,
/// and the mapped region will always round up to the neareest page boundary.
///
/// Therefore, the minimum size serialized is always one page (4096 bytes). Even if
/// we made this smaller, a full 4096 bytes are always allocated and cleared.
/// The `rkyv`+Buffer method hides the details of page alignment.
///
/// When serializing data manually, you need to guarantee the page alignment property.
/// One way to do this is to request a memory page using `xous::syscall::map_memory()`.
/// This is an explicit way to create a page of memory, and you must also unmap it
/// once you are done. Another way to do it is to allocate it on the stack, but, in
/// order to guarantee mapability, the structure has to be decorated with
/// `#[repr(C, align(4096))]`. This example uses stack allocation, and thus we create
/// a page-sized, page-aligned RawData structure as below.
#[repr(C, align(4096))]
pub struct RawData {
    raw: [u8; 4096],
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// lib.rs:
impl MyService {
    // ... new(), etc.

    /// Send some `data` to the server. It'll get there when it gets there.
    /// This example uses `rkyv` to serialize data into a compound structure.
    pub fn push_and_get_data_rkyv(&amp;self, data: &amp;mut [u8], desc: &amp;str) -&gt; Result&lt;(), xous::Error&gt; {
        let mut rec = CompoundData {
            data: [0u8; 1000],
            len: 0,
            description: xous_ipc::String::new(),
        };
        if data.len() &gt; rec.data.len() {
            return Err(xous::Error::OutOfMemory);
        }
        for (&amp;s, d) in data.iter().zip(rec.data.iter_mut()) {
            *d = s;
        }
        rec.len = data.len() as u16;
        rec.description.append(desc).ok(); // overflows are silently truncated

        // now convert it into a Xous::Buffer, which can then be lent to the server
        let mut buf = Buffer::into_buf(rec).or(Err(xous::Error::InternalError))?;
        buf.lend_mut(self.conn, Opcode::PushDataRkyv.to_u32().unwrap()).map(|_| ())?;

        let response = buf.as_flat::&lt;CompoundData, _&gt;().unwrap();
        if response.data.len() &gt; data.len() || response.data.len() &gt; response.data.len() {
            Err(xous::Error::OutOfMemory)
        } else {
            // copy the data back
            for (&amp;s, d) in response.data[..response.len as usize].iter().zip(data.iter_mut()) {
                *d = s;
            }
            Ok(())
        }
    }

    /// Send 32 bytes of `data` to a server. This example uses explicit serialization into a raw buffer.
    pub fn push_data_manual(&amp;self, data: &amp;mut [u8; 32]) -&gt; Result&lt;(), xous::Error&gt; {
        // RawData can be sized smaller, but all IPC memory messages are rounded up to the nearest page
        // The sizing here reflects that explicitly. Using `rkyv` does not change this, it just hides it.
        let mut request = RawData { raw: [0u8; 4096] };
        for (&amp;s, d) in data.iter().zip(request.raw.iter_mut()) {
            *d = s;
        }
	// we need to guarantee that RawData is a page-aligned, page-sized stack allocation.
	// See comment on the data structure for more information.
        let buf = unsafe {
            xous::MemoryRange::new(
                &amp;mut request as *mut RawData as usize,
                core::mem::size_of::&lt;RawData&gt;(),
            )
            .unwrap()
        };
        let response = xous::send_message(
            self.conn,
            xous::Message::new_lend_mut(
                Opcode::PushDataExplicit.to_usize().unwrap(),
                buf,
                None, // valid and offset are not used in explicit implementations
                None, // and are thus free to bind to other applications
            ),
        );
        match response {
            Ok(xous::Result::MemoryReturned(_offset, _valid)) =&gt; {
                // contrived example just copies whatever comes back from the server
                let response = buf.as_slice::&lt;u8&gt;();
                for (&amp;s, d) in response.iter().zip(data.iter_mut()) {
                    *d = s;
                }
                Ok(())
            }
            Ok(_) =&gt; Err(xous::Error::InternalError), // wrong return type
            Err(e) =&gt; Err(e)
        }
    }
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// main.rs:
fn xmain() -&gt; ! {
    // ... preamble
    let mut storage = Vec::&lt;CompoundData&gt;::new();
    let mut raw_data = [0u8; 32];
    loop {
        let mut msg = xous::receive_message(sid).unwrap();
        match FromPrimitive::from_usize(msg.body.id()) {
            /// This will get processed whenever the server gets scheduled, which has no strict
            /// relationship to the caller's state. However, messages are guaranteed
            /// to be processed in-order.
            Some(Opcode::PushDataRkyv) =&gt; {
                let mut buffer = unsafe {
                    Buffer::from_memory_message_mut(msg.body.memory_message_mut().unwrap())
                };
                let mut data = buffer.to_original::&lt;PushDataRkyv, _&gt;().unwrap();
                storage.push(data);
                // A contrived return value.
                data.len = 1;
                data.data[0] = 42;
                // Note that you can stick *any* `rkyv`-derived struct
                // into the buffer as a return &quot;value&quot;. We just happen to re-use
                // the same structure defintion here for expedience
                // However, it's up to the recipient to know the returned type,
                // and to deserialize it correctly. Nothing prevents type mismatches
                // across IPC boundaries!
                buffer.replace(data).expect(&quot;couldn't serialize return&quot;);
                // `msg` goes out of scope at this point, triggering `Drop` and thus unblocking the caller
            },
            Some(Opcode::PushDataExplicit) =&gt; {
                let body = msg.body.memory_message_mut().expect(&quot;incorrect message type received&quot;);
                let mut data = body.buf.as_slice_mut::&lt;u8&gt;();
                for (&amp;s, d) in data.iter().zip(raw_data.iter_mut()) {
                    *d = s;
                }
                // Very contrived example of &quot;returning&quot; data. Just poke something into the first byte.
                data[0] = 42;
                // there is no `replace()` because `data` is the original message memory: this is
                // unlike the previous example where `to_original()` creates a copy of the data.

                // `msg` goes out of scope at this point, triggering `Drop` and thus unblocking the caller
            }
            // .. other match statements
        }
    }
    // ... postamble
}
</code></pre>
<h1><a class="header" href="#asynchronous-idioms-or-push-notifications" id="asynchronous-idioms-or-push-notifications">Asynchronous Idioms or &quot;Push Notifications&quot;</a></h1>
<p>Push notifications are used when we want to be alerted of a truly unpredictable, asynchronous event that can happen at any time.</p>
<p>One of the main challenges of push notifications is not disclosing your <code>SID</code> to the notifying server. Remember, anyone with your <code>SID</code> can invoke any method on your server, including more sensitive ones.</p>
<p>The idiom here is to create and reveal a &quot;single-purpose&quot; server, whose sole job is to receive the push notification from the notifier, and forward this message back to the main server. The single purpose server exists on the <code>lib</code> side, and is thus the caller controls it and its construction. It runs in its own dedicated thread; thus, the single-purpose server spends most of its life blocked and not consuming CPU resources, and only springs to action once a notification arrives.</p>
<p>This pattern has the following properties:</p>
<ul>
<li>No disclosure of the main loop <code>SID</code></li>
<li>An extra &quot;bounce&quot; required for asynchronous notifications</li>
</ul>
<p>The example below is taken from the <code>NetManager</code>'s wifi state change subscription service, and trimmed down to the core bits.</p>
<pre><code class="language-rust noplayground ignore">// inside api.rs
// used for managing susbscriptions
#[derive(Debug, Archive, Serialize, Deserialize, Copy, Clone)]
pub(crate) struct WifiStateSubscription {
    // this is the &quot;single-purpose&quot; SID
    pub sid: [u32; 4],
    // this is the opcode dispatch number to use on the recipient side. Everyone
    // can have a different opcode table, so we must remember this with each SID.
    pub opcode: u32,
}

// all of the below sub-structures are `rkyv` serializeable
#[derive(Debug, Copy, Clone, rkyv::Archive, rkyv::Serialize, rkyv::Deserialize)]
pub struct WlanStatusIpc {
    pub ssid: Option&lt;SsidRecord&gt;,
    pub link_state: u16,
    pub ipv4: [u16; com_rs_ref::ComState::WLAN_GET_IPV4_CONF.r_words as usize],
}
// the `from_status()` method is a convenience trait that can take data from a native
// representation to an IPC-compatible version
impl WlanStatusIpc {
    pub fn from_status(status: WlanStatus) -&gt; Self {
        WlanStatusIpc {
            ssid: status.ssid,
            link_state: status.link_state as u16,
            ipv4: status.ipv4.encode_u16(),
        }
    }
}

#[derive(num_derive::FromPrimitive, num_derive::ToPrimitive, Debug)]
pub(crate) enum Opcode {
    // add a subscriber to our push notifications
    SubscribeWifiStats,
    // remove a subscriber
    UnsubWifiStats,
    // this triggers a push notification; it's contrived for simplicity in this pared-down example
    StateChangeEvent,
    // ------ API opcodes to be discussed in detail below ------
    /// Exits the server
    Quit,
}

</code></pre>
<pre><code class="language-rust noplayground ignore">// inside lib.rs
pub struct NetManager {
    netconn: NetConn,
    wifi_state_cid: Option&lt;CID&gt;,
    wifi_state_sid: Option&lt;xous::SID&gt;,
}
impl NetManager {
    pub fn new() -&gt; NetManager {
        NetManager {
            netconn: NetConn::new(&amp;xous_names::XousNames::new().unwrap()).expect(&quot;can't connect to Net Server&quot;),
            wifi_state_cid: None,
            wifi_state_sid: None,
        }
    }
    pub fn wifi_state_subscribe(&amp;mut self, return_cid: CID, opcode: u32) -&gt; Result&lt;(), xous::Error&gt; {
        if self.wifi_state_cid.is_none() {
            let onetime_sid = xous::create_server().unwrap();
            let sub = WifiStateSubscription {
                sid: onetime_sid.to_array(),
                opcode
            };
            let buf = Buffer::into_buf(sub).or(Err(xous::Error::InternalError))?;
            buf.send(self.netconn.conn(), Opcode::SubscribeWifiStats.to_u32().unwrap()).or(Err(xous::Error::InternalError))?;

            // this thread is the &quot;bouncer&quot; that takes the status data and sends it on
            // to our local private server. Note that it only has two opcodes, which limits
            // the attack surface exposed to a ptoentially untrusted subscriber.
            self.wifi_state_cid = Some(xous::connect(onetime_sid).unwrap());
            self.wifi_state_sid = Some(onetime_sid);
            let _ = std::thread::spawn({
                let onetime_sid = onetime_sid.clone();
                let opcode = opcode.clone();
                move || {
                    loop {
                        let msg = xous::receive_message(onetime_sid).unwrap();
                        match FromPrimitive::from_usize(msg.body.id()) {
                            Some(WifiStateCallback::Update) =&gt; {
                                let buffer = unsafe {
                                    Buffer::from_memory_message(msg.body.memory_message().unwrap())
                                };
                                // have to transform it through the local memory space because you can't re-lend pages
                                let sub = buffer.to_original::&lt;WlanStatusIpc, _&gt;().unwrap();
                                let buf = Buffer::into_buf(sub).expect(&quot;couldn't convert to memory message&quot;);
                                buf.lend(return_cid, opcode).expect(&quot;couldn't forward state update&quot;);
                            }
                            Some(WifiStateCallback::Drop) =&gt; {
                                xous::return_scalar(msg.sender, 1).unwrap();
                                break;
                            }
                            _ =&gt; {
                                log::error!(&quot;got unknown opcode: {:?}&quot;, msg);
                            }
                        }
                    }
                    xous::destroy_server(onetime_sid).unwrap();
                }
            });
            Ok(())
        } else {
            // you can only hook this once per object
            Err(xous::Error::ServerExists)
        }
    }
    /// If we're not already subscribed, returns without error.
    pub fn wifi_state_unsubscribe(&amp;mut self) -&gt; Result&lt;(), xous::Error&gt; {
        if let Some(handler) = self.wifi_state_cid.take() {
            if let Some(sid) = self.wifi_state_sid.take() {
                let s = sid.to_array();
                send_message(self.netconn.conn(),
                    Message::new_blocking_scalar(Opcode::UnsubWifiStats.to_usize().unwrap(),
                    s[0] as usize,
                    s[1] as usize,
                    s[2] as usize,
                    s[3] as usize,
                    )
                ).expect(&quot;couldn't unsubscribe&quot;);
            }
            send_message(handler, Message::new_blocking_scalar(WifiStateCallback::Drop.to_usize().unwrap(), 0, 0, 0, 0)).ok();
            unsafe{xous::disconnect(handler).ok()};
        }
        Ok(())
    }
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// main-side code
#[xous::xous_main]
fn xmain() -&gt; ! {
    // ... other stuff ...
    let mut wifi_stats_cache: WlanStatus = WlanStatus::from_ipc(WlanStatusIpc::default());
    let mut status_subscribers = HashMap::&lt;xous::CID, WifiStateSubscription&gt;::new();
    loop {
        let mut msg = xous::receive_message(sid).unwrap();
        // ... other opcodes ...
        Some(Opcode::SubscribeWifiStats) =&gt; {
            let buffer = unsafe {
                Buffer::from_memory_message(msg.body.memory_message().unwrap())
            };
            let sub = buffer.to_original::&lt;WifiStateSubscription, _&gt;().unwrap();
            let sub_cid = xous::connect(xous::SID::from_array(sub.sid)).expect(&quot;couldn't connect to wifi subscriber callback&quot;);
            status_subscribers.insert(sub_cid, sub);
        },
        Some(Opcode::UnsubWifiStats) =&gt; msg_blocking_scalar_unpack!(msg, s0, s1, s2, s3, {
            let sid = [s0 as u32, s1 as u32, s2 as u32, s3 as u32];
            let mut valid_sid: Option&lt;xous::CID&gt; = None;
            for (&amp;cid, &amp;sub) in status_subscribers.iter() {
                if sub.sid == sid {
                    valid_sid = Some(cid)
                }
            }
            xous::return_scalar(msg.sender, 1).expect(&quot;couldn't ack unsub&quot;);
            if let Some(cid) = valid_sid {
                status_subscribers.remove(&amp;cid);
                unsafe{xous::disconnect(cid).ok();}
            }
        }),
        // contrived state change event. Use the below idiom whenever you need to send a push notification.
        Some(Opcode::StateChangeEvent) =&gt; {
            // ... other code to handle the state change

            // iterate through all the subscribers and send the notification
            for &amp;sub in status_subscribers.keys() {
                let buf = Buffer::into_buf(WlanStatusIpc::from_status(wifi_stats_cache)).or(Err(xous::Error::InternalError)).unwrap();
                buf.send(sub, WifiStateCallback::Update.to_u32().unwrap()).or(Err(xous::Error::InternalError)).unwrap();
            }
        }
    }
}
</code></pre>
<h1><a class="header" href="#deferred-response" id="deferred-response">Deferred Response</a></h1>
<p>Deferred response is a variant of synchronous messaging. In this case, the caller blocks, but the callee is free to process new messages (typically to help compute results that evnetually unblock the caller).</p>
<p>As of Xous 0.9.7, the trick to deferred response is different between <code>scalar</code> and <code>memory</code> messages.</p>
<ul>
<li>For <code>scalar</code> messages, one needs to store the <code>msg.sender</code> field (a <code>usize</code>) and delay the <code>xous::return_scalar(sender, value)</code> call until the appropriate time.</li>
<li>For <code>memory</code> messages, one needs to store the entire <code>MessageEnvelope</code>, so that it does not go out of scope. <code>memory</code> messages automatically call the appropriate syscall (<code>return_memory_offset_valid</code> for <code>lend</code> and <code>lend_mut</code>, <code>unmap_memory</code> for <code>send</code>) in their <code>Drop</code> trait implementation.</li>
</ul>
<p>Future versions of Xous may or may not implement a <code>Drop</code> method which automatically returns <code>scalar</code> messages when they go out of scope, this is a topic of active discussion. However, as is the case with all the other idioms, the pattern is different from <code>scalar</code> and <code>memory</code> types, so, regardless, they will be treated with separate examples.</p>
<h2><a class="header" href="#scalar-pattern-2" id="scalar-pattern-2">Scalar Pattern</a></h2>
<p>This is very close to the thing that's actually implemented for synchronizing all the servers during a suspend/resume event.</p>
<pre><code class="language-rust noplayground">// api.rs
pub(crate) enum Opcode {
    WaitUntilReady,
    TheBigEvent,
    // ... and other ops
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// lib.rs:
impl MyService {
    // ... new(), etc.

    /// This will wait until the main loop decides it's ready to unblock us.
    pub fn wait_until_ready(&amp;self) -&gt; Result&lt;(), xous::Error&gt; {
        send_message(self.conn,
            Message::new_blocking_scalar(Opcode::WaitUntilReady.to_usize().unwrap()),
                0, 0, 0, 0
            )
        ).map(|_| ())
    }
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// main.rs:
fn xmain() -&gt; ! {
    // ... preamble
    let mut waiting = Vec::&lt;MessageSender&gt;::new();
    loop {
        let msg = xous::receive_message(sid).unwrap();
        match FromPrimitive::from_usize(msg.body.id()) {
            Some(Opcode::WaitUntilReady) =&gt; xous::msg_blocking_scalar_unpack!(msg, _, _, _, _, {
                // store the message sender;
                // the sender continues to block because `xous::return_scalar()` has not been called
                waiting.push(msg.sender);
                // execution continues on here
            }),
            // .. this loop is still available to do things, even though the callers are blocked ..
            // stuff happens until something triggers TheBigEvent:
            Some(Opcode::TheBigEvent) =&gt; {
                for sender in waiting.drain(..) {
                    // the argument is arbitrary. `return_scalar2` can also be used.
                    xous::return_scalar(sender, 1).expect(&quot;couldn't unblock sender&quot;);
                }
                // All the waiting processes are now unblocked.
            }
            // .. other match statements
        }
    }
    // ... postamble
}
</code></pre>
<h2><a class="header" href="#memory-pattern-2" id="memory-pattern-2">Memory Pattern</a></h2>
<pre><code class="language-rust noplayground ignore">// api.rs
pub(crate) enum Opcode {
    GetDeferredData,
    Event,
    // ... and other ops
}
#[derive(rkyv::Archive, rkyv::Serialize, rkyv::Deserialize)]
pub struct DeferredData {
    pub spec: u32,
    pub description: xous_ipc::String::&lt;128&gt;,
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// lib.rs:
impl MyService {
    // ... new(), etc.

    pub fn get_data_blocking(&amp;self, spec: u32) -&gt; Result&lt;String, xous::Error&gt; {
        let mut rec = DeferredData {
            spec,
            description: xous_ipc::String::new(),
        };

        let mut buf = Buffer::into_buf(rec).or(Err(xous::Error::InternalError))?;
        buf.lend_mut(self.conn, Opcode::GetDeferredData.to_u32().unwrap()).map(|_| ())?;

        let response = buf.as_flat::&lt;DeferredData, _&gt;().unwrap();
        Ok(String::new(response.description.as_str().unwrap_or(&quot;UTF-8 error&quot;)))
    }
}
</code></pre>
<pre><code class="language-rust noplayground ignore">// main.rs:
fn xmain() -&gt; ! {
    // ... preamble
    // if you are sure there will never be multiple deferred messages, you can just use an
    // Option&lt;MessageEnvelope&gt; and .take() to remove it from scope, instead of Vec and .drain()
    let mut storage = Vec::&lt;xous::MessageEnvelope&gt;::new();
    let mut spec: u32 = 0;
    loop {
        let mut msg = xous::receive_message(sid).unwrap();
        match FromPrimitive::from_usize(msg.body.id()) {
            /// This will get processed whenever the server gets scheduled, which has no strict
            /// relationship to the caller's state. However, messages are guaranteed
            /// to be processed in-order.
            Some(Opcode::GetDeferredData) =&gt; {
                spec += {
                    // any incoming arguments are processed in a block like this to ensure
                    // that the `msg` has no ownership interference with `spec`.
                    let buffer = unsafe {
                        Buffer::from_memory_message(msg.body.memory_message().unwrap())
                    };
                    let data = buffer.to_original::&lt;DeferredData, _&gt;().unwrap();
                    data.spec
                };
                storage.push(msg);
                // `msg` is now pushed into the scope of `storage`, which prevents `Drop`
                // from being called, thus continuing to block the caller.
            },
            // ... other processing happens, perhaps guided by the value in `spec`
            Some(Opcode::Event) =&gt; {
                let result = DeferredData {
                    spec: 0,
                    description: xous_ipc::String::from_str(&quot;something happened!&quot;),
                };
                // `drain()` takes `msg` back out of the scope of `storage`, and
                // unless it is bound to another variable outside of this scope,
                // it will Drop and unblock the caller at the end of this block.
                for mut sender in storage.drain(..) {
                    let mut response = unsafe {
                        Buffer::from_memory_message_mut(sender.body.memory_message_mut().unwrap())
                    };
                    response.replace(result).unwrap();
                }
            }
            // .. other match statements
        }
    }
    // ... postamble
}
</code></pre>
<h1><a class="header" href="#forwarding-messages" id="forwarding-messages">Forwarding Messages</a></h1>
<p>Because server IDs are used to protect APIs, there arises occassions where
servers need to be firewalled: a private server within a crate may implement
a range of powerful and dangerous APIs, of which only a small portion should
be revealed to external callers.</p>
<p>The general idiom in this case is to:</p>
<ol>
<li>Create a process-private server that contains all the APIs. The server is not registered with <code>xous-names</code>; it is entirely a secret within the crate.</li>
<li>Create a process-public server that contains only the public APIs. This server is registered with <code>xous-names</code> and it may have a connection limit of <code>None</code>, e.g., anyone and everyone may connect to it.</li>
<li>Certain messages are forwarded from the process-public server to the process-private server.</li>
</ol>
<p>In order to support this idiom, messages have a <code>.forward()</code> call. Usage is straightfoward:</p>
<pre><code class="language-rust noplayground ignore">    // A private server that can do many powerful things
    let cm_sid = xous::create_server().expect(&quot;couldn't create connection manager server&quot;);
    let cm_cid = xous::connect(cm_sid).unwrap();
    thread::spawn({
        move || {
            connection_manager::connection_manager(cm_sid);
        }
    });

    loop {
        let mut msg = xous::receive_message(net_sid).unwrap();
        // .. other code

        // These messages are forwarded on to the private server
        // This one is a `lend` of a memory message
        Some(Opcode::SubscribeWifiStats) =&gt; {
            msg.forward(
                cm_cid,
                ConnectionManagerOpcode::SubscribeWifiStats as _)
            .expect(&quot;couldn't forward subscription request&quot;);
        }
        // This one is a `blocking_scalar` scalar message type
        Some(Opcode::UnsubWifiStats) =&gt; {
            msg.forward(
                cm_cid,
                connection_manager::ConnectionManagerOpcode::UnsubWifiStats as _)
            .expect(&quot;couldn't forward unsub request&quot;);
        },
    }
</code></pre>
<p>Other usage notes:</p>
<ul>
<li>Message types cannot be transformed across the forwarding boundary.</li>
<li>You are allowed to inspect a Memory <code>msg</code> by unpacking it into a <code>Buffer</code>, but you must make sure the <code>Buffer</code> goes out of scope before calling <code>.forward()</code> (perhaps by putting the inspection operation within its own block, e.g. a pair of curly braces).</li>
</ul>
<h1><a class="header" href="#graphics-toolkit" id="graphics-toolkit">Graphics Toolkit</a></h1>
<p>The Xous UX stack consists of three levels:</p>
<ol>
<li><code>Modals</code> and <code>Menu</code>s</li>
<li>The <code>GAM</code> (Graphical Abstraction Manager)</li>
<li>The <code>graphics-server</code></li>
</ol>
<h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<h2><a class="header" href="#modals-and-menus" id="modals-and-menus">Modals and Menus</a></h2>
<p>The <code>Modals</code> and <code>Menu</code> objects are pre-defined primitives that simplify the creation of Notifications, Checkboxes, Radioboxes, Text Entry boxes, Progress Bars, and Menus. They are as close as you get to a graphics toolkit in Xous.</p>
<h2><a class="header" href="#gam" id="gam">GAM</a></h2>
<p>Xous has a security-aware UX infrastructure that aims to make it difficult for rogue processes to pop up dialog boxes that could visually mimic system messages and password boxes.</p>
<p>The <code>GAM</code> is a layer that intermediates between the graphics toolkit and the hardware drivers, and enforces these security policies. It does this through the <code>Canvas</code> and <code>Layout</code> primitives.</p>
<p>The <code>Canvas</code> enforces a particular trust level associated with a region of the screen. White text on a black background is reserved for secure, trusted messages, and the <code>GAM</code> in combination with the trust level encoded in a <code>Canvas</code> is responsible for enforcing that rule. This is also where the <code>deface</code> operation occurs, the series of random lines that appear on items in the background.</p>
<p><code>Layout</code>s contain one or more <code>Canvas</code> objects and are used to define, at a coarse level, regions of the screen, such as where the status bar belongs, the IME, and so forth.</p>
<h2><a class="header" href="#graphics-server" id="graphics-server">Graphics Server</a></h2>
<p>The <code>graphics-server</code> is responsible for rendering primitives such as circles, lines, and glyphs to the frame buffer. It places no restrictions on where pixels may be placed.</p>
<p>The <code>graphics-server</code> uses the <code>xous-names</code> registry mechanism to restrict its access. No user processes can talk directly to it as a result.</p>
<h1><a class="header" href="#modals" id="modals">Modals</a></h1>
<p>You can use the <code>Modals</code> server to pop up the following objects:</p>
<ul>
<li>Notifications
<ul>
<li>Static: shows a message plus an &quot;Okay&quot; button</li>
<li>Dynamic: can sequence through multiple messages</li>
</ul>
</li>
<li>Checkboxes (multi-select list)</li>
<li>Radioboxes (single-select list)</li>
<li>Text Entry with validator</li>
<li>Progress bars</li>
</ul>
<p>To use <code>Modals</code> in your code, you will need to add <code>modals</code> to your <code>Cargo.toml</code> file. From an application in the <code>apps</code> directory:</p>
<pre><code class="language-toml">modals = {path = &quot;../../services/modals&quot;}
</code></pre>
<p>In all of the examples, you will need this pre-amble to create the <code>modals</code> object. The object can be re-used as many times as you like.</p>
<pre><code class="language-rust noplayground ignore">// connect to the modals object through the name resolver
let xns = XousNames::new().unwrap();
let modals = modals::Modals::new(&amp;xns).unwrap();
</code></pre>
<h2><a class="header" href="#static-notification" id="static-notification">Static Notification</a></h2>
<pre><code class="language-rust noplayground ignore">modals.show_notification(&quot;This is a test!&quot;).expect(&quot;notification failed&quot;);
</code></pre>
<p>This will pop up a notification that says &quot;This is a test!&quot;. Execution blocks at this line until the user pressses any key to acknowledge the notification.</p>
<h2><a class="header" href="#progress-bar" id="progress-bar">Progress bar</a></h2>
<p>One can create a progress bar using the <code>start_progress()</code> method, with the following parameters:</p>
<ul>
<li><code>name</code>: A <code>&amp;str</code> that is the title of the progress bar</li>
<li><code>start</code>: A <code>u32</code> that is the starting ordinal</li>
<li><code>end</code>: A <code>u32</code> that is the ending ordinal</li>
<li><code>current</code>: A <code>u32</code> that is the initial point of the progress bar</li>
</ul>
<p><code>start</code> should be less than <code>end</code>, and <code>current</code> should be between <code>start</code> and <code>end</code>, inclusive.</p>
<p>Once the bar is created, you can update its progress using the <code>update_progress()</code> method. It takes a number that represents the current progress between the start and end ordinal.</p>
<p>The progress bar is closed by calling the <code>finish_progress()</code> method.</p>
<pre><code class="language-rust noplayground ignore">// the ticktimer is used just to introduce a delay in this example. Normally, you'd do something computationally useful instead of just waiting.
let tt = ticktimer_server::Ticktimer::new().unwrap();

let start = 1;
let end = 20;
modals.start_progress(&quot;Progress Quest&quot;, start, end, start).expect(&quot;couldn't raise progress bar&quot;);

for i in (start..end).step_by(2) {
    modals.update_progress(i).expect(&quot;couldn't update progress bar&quot;);
    tt.sleep_ms(100).unwrap();
}
modals.finish_progress().expect(&quot;couldn't dismiss progress bar&quot;);
</code></pre>
<h2><a class="header" href="#dynamic-notifications" id="dynamic-notifications">Dynamic Notifications</a></h2>
<p>Dynamic notifications are notifications which don't have an option for the user
to close them; instead, the calling program controls when the dialog can
be closed, and can also dynamically update the message. This is useful for
displaying, for example, multi-phase progress updates without stopping and
waiting for a user to hit &quot;OK&quot;.</p>
<p>The API is similar to that of the Progress Bar, in that there are start, update,
and close phases:</p>
<ul>
<li>To pop up the dynamic notification, use the <code>dynamic_notification(title: Option&lt;&amp;str&gt;, text: Option&lt;&amp;str&gt;)</code>
method. The both <code>title</code> and <code>text</code> are optional, but at least one is recommended, otherwise
you get an empty notification.</li>
<li>Updates to the notification are done using <code>dynamic_notification_update(title: Option&lt;&amp;str&gt;, text: Option&lt;&amp;str&gt;)</code>.
Arguments that are <code>None</code> do not update, and show the same text as before.</li>
<li>Once you are finished showing the set of notifications, you must close the
dialog with <code>dynamic_notification_close()</code>.</li>
</ul>
<h2><a class="header" href="#text-entry" id="text-entry">Text entry</a></h2>
<p>One can request text entry using the <code>get_text()</code> method. This takes the following parameters:</p>
<ul>
<li><code>prompt</code>: A <code>&amp;str</code> that is the prompt to the user</li>
<li><code>validator</code>: An <code>Option&lt;fn(TextEntryPayload, u32) -&gt; Option&lt;ValidatorErr&gt;&gt;</code>. This is an optional function that takes the text entry payload, along with a dispatch opcode. The dispatch opcode allows a single validator function to be re-used across multiple invocations of <code>get_text()</code>.</li>
<li><code>validator_op</code>: An <code>Option&lt;u32&gt;</code>. When <code>Some()</code>, the argument inside is passed to the validator to indicate which type of text is being validated.</li>
</ul>
<p>The idea behind the <code>validator_op</code> is that you could create an <code>Enum</code> type that specifies the type of text you're entering, and you would pass the <code>u32</code> version of that <code>Enum</code> to the <code>get_text()</code> call so that a single <code>validator</code> function can be used to check multiple types of text entry.</p>
<pre><code class="language-rust noplayground ignore">// you can also use the num_derive crate to have bi-directional transformation of the enum
enum ValidatorOp {
    Int2 = 0,
    Int = 1,
}
//
fn my_code() {
    // ... insert code to create modals object, etc.
    match modals.get_text(&quot;Input an integer greater than 2&quot;, Some(test_validator), Some(ValidatorOp::Int2 as u32)) {
        Ok(text) =&gt; {
            log::info!(&quot;Input: {}&quot;, text.0);
        }
        _ =&gt; {
            log::error!(&quot;get_text failed&quot;);
        }
    }
    match modals.get_text(&quot;Input any integer&quot;, Some(test_validator), Some(ValidatorOp::Int2 as u32)) {
        Ok(text) =&gt; {
            log::info!(&quot;Input: {}&quot;, text.0);
        }
        _ =&gt; {
            log::error!(&quot;get_text failed&quot;);
        }
    }
}

fn test_validator(input: TextEntryPayload, opcode: u32) -&gt; Option&lt;xous_ipc::String::&lt;256&gt;&gt; {
    let text_str = input.as_str();
    match text_str.parse::&lt;u32&gt;() {
        Ok(input_int) =&gt;
        if opcode == ValidatorOp::Int2 as u32 {
            if input_int &lt;= 2 {
                return Some(xous_ipc::String::&lt;256&gt;::from_str(&quot;input must be larger than 2&quot;))
            } else {
                return None
            }
        } else if opcode == ValidatorOp::Int as u32 {
            return None
        } else {
            panic!(&quot;unknown discriminant&quot;);
        }
        _ =&gt; return Some(xous_ipc::String::&lt;256&gt;::from_str(&quot;enter an integer value&quot;))
    }
}
</code></pre>
<h2><a class="header" href="#radio-box" id="radio-box">Radio Box</a></h2>
<p>A radio box is a mechanism to force a user to pick exactly one item from a list of options.</p>
<p>One can construct a radio box by first repeatedly calling <code>add_list_item()</code> with a <code>&amp;str</code>
description of the items to select, and then calling <code>get_radiobutton()</code> with a <code>&amp;str</code> of
the prompt. The returned value will be the <code>&amp;str</code> description of the selected item.</p>
<p>Note that upon completion of the radio box, the list of items is automatically cleared
in preparation for another invocation of <code>modals</code>.</p>
<pre><code class="language-rust noplayground ignore">const RADIO_TEST: [&amp;'static str; 4] = [
    &quot;zebra&quot;,
    &quot;cow&quot;,
    &quot;horse&quot;,
    &quot;cat&quot;,
];

for item in RADIO_TEST {
    modals.add_list_item(item).expect(&quot;couldn't build radio item list&quot;);
}
match modals.get_radiobutton(&quot;Pick an animal&quot;) {
    Ok(animal) =&gt; log::info!(&quot;{} was picked&quot;, animal),
    _ =&gt; log::error!(&quot;get_radiobutton failed&quot;),
}
</code></pre>
<h2><a class="header" href="#check-box" id="check-box">Check Box</a></h2>
<p>A check box is a mechanism to present a user with a list of several options, of which
they can select none, some, or all of them.</p>
<p>The usage is nearly identical to the Radio Box above, except that the return value
is a <code>Vec::&lt;String&gt;</code>. The <code>Vec</code> will be empty if no elements are selected.</p>
<pre><code class="language-rust noplayground ignore">const CHECKBOX_TEST: [&amp;'static str; 5] = [
    &quot;happy&quot;,
    &quot;😃&quot;,
    &quot;安&quot;,
    &quot;peaceful&quot;,
    &quot;...something else!&quot;,
];

for item in CHECKBOX_TEST {
    modals.add_list_item(item).expect(&quot;couldn't build checkbox list&quot;);
}
match modals.get_checkbox(&quot;You can have it all:&quot;) {
    Ok(things) =&gt; {
        log::info!(&quot;The user picked {} things:&quot;, things.len());
        for thing in things {
            log::info!(&quot;{}&quot;, thing);
        }
    },
    _ =&gt; log::error!(&quot;get_checkbox failed&quot;),
}
</code></pre>
<h1><a class="header" href="#menus" id="menus">Menus</a></h1>
<p>Menus are created with the help of the <code>menu_matic()</code> convenience call.</p>
<p>Conceptually, a Menu in Xous is a list of <code>MenuItem</code>. Graphically, the menus
are rendered in the order that the <code>MenuItem</code>s are added to the list. When a <code>MenuItem</code> is selected, it fires a message off to another server to effect the corresponding outcome desired of the logical menu description.</p>
<p>Thus, each <code>MenuItem</code> has the following fields:</p>
<ul>
<li>A <code>name</code> describing the menu item, limited to a 64-byte long unicode string</li>
<li>An <code>Option</code> for an <code>action connection</code>. This is a CID to a server to which a message will be sent upon selecting the item. If <code>None</code>, the menu item does nothing and just closes the menu.</li>
<li>An <code>action opcode</code>. This is a <code>u32</code> value that corresponds to the discriminant of the <code>enum</code> used to dispatch opcodes in your main loop (e.g., the parameter passed as <code>msg.body.id()</code>).</li>
<li>A <code>MenuPayload</code>, which is an <code>enum</code> that currently can only be a <code>Scalar</code> payload consisting of up to 4 <code>u32</code> values. There's a future provision for this to be extended to a small <code>Memory</code> message but it is not yet implemented (please <a href="https://github.com/betrusted-io/xous-core/issues">open an issue</a> if you need this feature, and helpfully remind the maintainers to also update the Xous Book docs once this is done).</li>
<li><code>close on select</code> - when set to true, the menu will automatically close when the item is selected.</li>
</ul>
<p>So, when a <code>MenuItem</code> is selected by the user, the menu implementation will fire off a <code>Scalar</code> message to the server identified by <code>action_conn</code> with the opcode specified by <code>action opcode</code> and a payload of <code>MenuPayload</code>. The receiving server can asynchronously receive this message in its main loop and act upon the menu selection.</p>
<p>The general idiom is to create a <code>Vec</code> of <code>MenuItem</code>s, and then pass them into <code>MenuMatic</code>, as seen below:</p>
<pre><code class="language-rust noplayground ignore">pub fn create_kbd_menu(status_conn: xous::CID, kbd_mgr: xous::SID) -&gt; MenuMatic {
    let mut menu_items = Vec::&lt;MenuItem&gt;::new();

    let code: usize = KeyMap::Qwerty.into();
    menu_items.push(MenuItem {
        name: xous_ipc::String::from_str(&quot;QWERTY&quot;),
        action_conn: Some(status_conn),
        action_opcode: StatusOpcode::SetKeyboard.to_u32().unwrap(),
        action_payload: MenuPayload::Scalar([code as u32, 0, 0, 0]),
        close_on_select: true,
    });
    let code: usize = KeyMap::Dvorak.into();
    menu_items.push(MenuItem {
        name: xous_ipc::String::from_str(&quot;Dvorak&quot;),
        action_conn: Some(status_conn),
        action_opcode: StatusOpcode::SetKeyboard.to_u32().unwrap(),
        action_payload: MenuPayload::Scalar([code as u32, 0, 0, 0]),
        close_on_select: true,
    });
    menu_items.push(MenuItem {
        name: xous_ipc::String::from_str(&quot;Close Menu&quot;),
        action_conn: None,
        action_opcode: 0,
        action_payload: MenuPayload::Scalar([code as u32, 0, 0, 0]),
        close_on_select: true,
    });

    menu_matic(menu_items, gam::KBD_MENU_NAME, Some(kbd_mgr)).expect(&quot;couldn't create MenuMatic manager&quot;)
}

</code></pre>
<p>This will create a menu with three items, &quot;QWERTY&quot;, &quot;Dvorak&quot;, and &quot;Close Menu&quot;. When, for example, the &quot;QWERTY&quot; item is selected, it will send a message to the server pointed to be <code>status_conn</code>, with the argument of <code>StatusOpcode::SetKeyboard</code> as a<code>u32</code>, and an argument consisting of <code>[code, 0, 0, 0,]</code>. In this case, only <code>code</code> has meaning, and the other three are just placeholders.</p>
<p>The third menu item has <code>None</code> for the connection, so when it is selected, no messages are sent and the menu is simply closed.</p>
<h2><a class="header" href="#raising-the-menu" id="raising-the-menu">Raising the Menu</a></h2>
<p>Once you have created your menu, you can cause the menu to pop up with the following <code>gam</code> call:</p>
<pre><code class="language-rust noplayground ignore">gam.raise_menu(gam::KBD_MENU_NAME).expect(&quot;couldn't raise keyboard layout submenu&quot;);
</code></pre>
<p>The menu will automatically close if <code>close_on_select</code> is <code>true</code>.</p>
<h2><a class="header" href="#permission-to-create-menus" id="permission-to-create-menus">Permission to Create Menus</a></h2>
<p>What's the <code>gam::KBD_MENU_NAME</code> field all about?</p>
<p>In order to prevent rogue processes from creating menus willy-nilly that resemble, for example, the main menu but firing off forged messages to undesired processes, there is an access control list for menus.</p>
<p>The access control list is kept in the <code>gam</code>, and can be found in <code>services/gam/src/lib.rs</code>. You must add a <code>const str</code> that gives your menu a unique name, and insert it into the <code>EXPECTED_BOOT_CONTEXTS</code> structure, otherwise, the <code>gam</code> will deny the creation of your menu item. The access list is &quot;trust on first use&quot;, and secure operations such as accessing the root keys will not be allowed to proceed until all contexts have been allocated. Therefore, if you are creating a menu, you need to call <code>menu_matic()</code> early in the boot process, or else you will be unable to unlock the PDDB.</p>
<p>Permissions Checklist:</p>
<ol>
<li>Give your menu a name in <code>services/gam/src/lib.rs</code></li>
<li>Add the name to <code>EXPECTED_BOOT_CONTEXTS</code></li>
<li>Claim your name with <code>menu_matic()</code> early in the boot process</li>
</ol>
<h2><a class="header" href="#modifying-the-menu" id="modifying-the-menu">Modifying the Menu</a></h2>
<p><code>menu_matic()</code> has a third argument, which is an <code>Option&lt;xous::SID&gt;</code>. If you never plan to modify your menu, you can leave it as <code>None</code>. However, if you want to do things such as dynamically create and remove menu items, or pre-select an index in the menu list, you will need to specify an SID. This is used to create the <code>MenuMatic</code> object, which is returned to the caller.</p>
<p>The SID is created as follows:</p>
<pre><code class="language-rust noplayground ignore">let kbd_mgr = xous::create_server().unwrap();
</code></pre>
<p><code>MenuMatic</code> has the following methods available on it:</p>
<ul>
<li><code>add_item(MenuItem)</code> - adds the <code>MenuItem</code> specified to the end of the menu list, returning <code>true</code> to indicate success.</li>
<li><code>delete_item(&amp;str)</code> - deletes an item with a <code>name</code> specified as the argument. Returns <code>true</code> to indicate success.</li>
<li><code>set_index(usize)</code> - sets the index pointer of the menu to the specified offset. Typically ued to create a &quot;default&quot; position for the menu before it is raised.</li>
<li><code>quit()</code> - exit and destory the <code>MenuMatic</code> server</li>
</ul>
<p>If you don't need the above functionality, it's recommended that you do not create the server, as it consumes memory and eats up connection and server name space.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
